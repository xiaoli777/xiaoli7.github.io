<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Binary tree</title>
    <url>/2021/Binary-tree/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><a href="https://en.wikipedia.org/wiki/Binary_tree">二叉树(Binary Tree)</a>是一种数据结构，它的每个父节点(parent)至多有两个子节点(children)，分别被称为<em>左孩子(the left child)<em>和</em>右孩子(the right child)</em>.</p>
<p><img src="/images/bt/bt-1.png"></p>
<p>如上图所示, 该二叉树的大小(size)为9且高度(height)为3，根结点(root)的值为2. 另外，这是一棵不平衡(unbalanced)且未排序(unsorted)的二叉树。</p>
<br>

<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><ul>
<li><p><strong>满二叉树(full binary tree)</strong></p>
<ul>
<li><p>除叶子节点(leaf)外，所有分支节点都含有2个非空子节点的二叉树</p>
</li>
<li><p>满二叉树上的节点要么有0个子节点，要么有2个子节点</p>
</li>
<li><p>满二叉树的子树(subtree)是单个顶点(vertex)，或同样是满二叉树</p>
<p><img src="/images/bt/bt-2.png"></p>
</li>
</ul>
</li>
<li><p><strong>完全二叉树(complete binary tree)</strong></p>
<ul>
<li><p>除了最后一层，其余层都是“满”的，且叶子节点尽可能向左靠齐</p>
</li>
<li><p>or 在最后一层中，移除最右边的叶子节点(rightmost leaves)</p>
</li>
<li><p>完全二叉树节点总数在1 ～ $2^h$ 之间，其中h为树的高度</p>
<p><img src="/images/bt/bt-3.png"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>完美二叉树(perfect binary tree)</strong><ul>
<li>完全二叉树 + 满二叉树</li>
</ul>
</li>
</ul>
<br>

<h2 id="二叉树属性"><a href="#二叉树属性" class="headerlink" title="二叉树属性"></a>二叉树属性</h2><ul>
<li><strong>在任意二叉树中，度数为2节点的个数等于叶子节点的个数减1</strong></li>
</ul>
<p>节点的度数等于其子节点的个数。因此，在二叉树中，节点的度数只可能为0，1和2。</p>
<p>当只有1个节点时，度为0。接着，每多出1个节点，同时会派生出1度。派生出的度和派生出的节点数一定相等。即：</p>
<p><code>节点总数 = 总度数 + 1</code></p>
<p>假设在一棵二叉树中，度数为2的节点数为<code>X2</code>，度数为1的节点数为<code>X1</code>，度数为0的节点数为<code>X0</code>。结合上式：</p>
<p><code>X2 + X1 + X0 = 2X2 + X1 + 1</code>，推出 <code>X2 = X0 - 1</code></p>
<p>因此，<strong>度数为2的节点个数等于叶节点数减1</strong></p>
<ul>
<li><strong>满二叉树定理：非空满二叉树的叶节点数等于其分支节点数加1</strong></li>
</ul>
<p>证明同上。在满二叉树中，度数为1的节点数为0。</p>
<ul>
<li><strong>一颗非空二叉树中，空子树的数目等于其节点数目加1</strong></li>
</ul>
<p>当仅有根节点时：二叉树有2个空子树，1个节点，结论成立。</p>
<p>接着，空子树和节点等量增长，结论成立。</p>
<ul>
<li><strong>满二叉树最少有2h+1个节点，最多有2^(h+1)-1个节点 (仅有根节点的二叉树的高度为0)</strong></li>
<li><strong>在完美二叉树中，假设叶子结点的个数为l，高度为h，则l=2^h，总结点个数n=2^(h+1)-1</strong></li>
</ul>
<br>

<h2 id="二叉树算法"><a href="#二叉树算法" class="headerlink" title="二叉树算法"></a>二叉树算法</h2><h4 id="二叉树的结点"><a href="#二叉树的结点" class="headerlink" title="二叉树的结点"></a>二叉树的结点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    elemType info;</span><br><span class="line">    binaryTreeNode&lt;elemType&gt; *left;</span><br><span class="line">    binaryTreeNode&lt;elemType&gt; *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的高度"><a href="#二叉树的高度" class="headerlink" title="二叉树的高度"></a>二叉树的高度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(binaryTreeNode&lt;elemType&gt; *btn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (btn == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(height(btn-&gt;left), height(btn-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的复制"><a href="#二叉树的复制" class="headerlink" title="二叉树的复制"></a>二叉树的复制</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyTree</span><span class="params">(binaryTreeNode&lt;elemType&gt;* &amp;copiedTreeRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">		binaryTreeNode&lt;elemType&gt;* otherTreeRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (otherTreeRoot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        copiedTreeRoot = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        copiedTreeRoot = <span class="keyword">new</span> binaryTreeNode&lt;elemType&gt;;</span><br><span class="line">        copiedTreeRoot-&gt;info = otherTreeRoot-&gt;info;</span><br><span class="line">        copyTree(copiedTreeRoot-&gt;left, otherTreeRoot-&gt;left);</span><br><span class="line">        copyTree(copiedTreeRoot-&gt;right, otherTreeRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的遍历-traverse"><a href="#二叉树的遍历-traverse" class="headerlink" title="二叉树的遍历 (traverse)"></a>二叉树的遍历 (traverse)</h4><ul>
<li><strong>前序</strong>遍历：根-&gt;左-&gt;右</li>
<li><strong>中序</strong>遍历：左-&gt;根-&gt;右</li>
<li><strong>后序</strong>遍历：左-&gt;右-&gt;根</li>
</ul>
<h5 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(binaryTreeNode&lt;elemType&gt; *btn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (btn == <span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; btn-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    preorder(btn-&gt;left);</span><br><span class="line">    preorder(btn-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(binaryTreeNode&lt;elemType&gt; *btn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (btn == <span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line">    inorder(btn-&gt;left);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; btn-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    inorder(btn-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(binaryTreeNode&lt;elemType&gt; *btn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (btn == <span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line">    postorder(btn-&gt;left);</span><br><span class="line">    postorder(btn-&gt;right);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; btn-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h5><p>需要额外的一个栈stack结构来辅助实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorderIteration</span><span class="params">(binaryTreeNode&lt;elemType&gt; *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;binaryTreeNode&lt;elemType&gt;*&gt; st;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        st.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">        binaryTreeNode&lt;elemType&gt; *cur = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cur-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//操作当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">            st.push(cur-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">            st.push(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderIteration</span><span class="params">(binaryTreeNode&lt;elemType&gt; *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;binaryTreeNode&lt;elemType&gt;*&gt; st;</span><br><span class="line"></span><br><span class="line">    binaryTreeNode&lt;elemType&gt; *cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur || !st.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">            st.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cur-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//操作当前节点</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderIteration</span><span class="params">(binaryTreeNode&lt;elemType&gt; *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;binaryTreeNode&lt;elemType&gt;*&gt; st;</span><br><span class="line">    binaryTreeNode&lt;elemType&gt; *pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        st.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">        binaryTreeNode&lt;elemType&gt; *cur = st.top();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 出栈条件：</span></span><br><span class="line"><span class="comment">         * 对于叶子节点：直接弹出</span></span><br><span class="line"><span class="comment">         * 对于非叶子节点：如果已经遍历过其左子节点或右子节点，则弹出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>((!cur-&gt;left &amp;&amp; !cur-&gt;right) || (pre &amp;&amp; (cur-&gt;left == pre || cur-&gt;right == pre)))&#123;</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cur-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//操作当前节点</span></span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//说明是一个非叶子节点，并且还未访问其左右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                st.push(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                st.push(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="层次遍历-Breadth-First-Search"><a href="#层次遍历-Breadth-First-Search" class="headerlink" title="层次遍历 (Breadth-First Search)"></a>层次遍历 (Breadth-First Search)</h5><p>需要额外的一个队列queue结构来辅助实现。</p>
<p>大致思想为：队列初始化时只有根节点，每个节点出队列时，将它子节点加入队列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(binaryTreeNode&lt;elemType&gt;* btn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(btn == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">queue</span>&lt;binaryTreeNode&lt;elemType&gt; *&gt; que; <span class="comment">//构造一个树结点指针的队列</span></span><br><span class="line">    que.push(btn);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        binaryTreeNode&lt;elemType&gt; *q = que.front();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        que.pop();</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;left != <span class="literal">nullptr</span>)  <span class="comment">//左子节点入队列</span></span><br><span class="line">            que.push(q-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;right != <span class="literal">nullptr</span>)  <span class="comment">//右子节点入队列</span></span><br><span class="line">            que.push(q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉树的算法思路：<strong>仅考虑当前结点的任务，将其余部分交给递归或迭代框架。</strong>其算法框架大致为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTFramework</span><span class="params">(binaryTreeNode&lt;elemType&gt;* btn, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (btn-&gt;val == target)</span><br><span class="line">        DoSometing;</span><br><span class="line">    <span class="keyword">if</span> (btn-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">        BTFramework(btn-&gt;left, target);</span><br><span class="line">    <span class="keyword">if</span> (btn-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">        BTFramework(btn-&gt;right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个以后再细说。。。</p>
<p>代码下载地址：<a href="https://xiaoli777.github.io/codes/BinaryTree.cpp">https://xiaoli777.github.io/codes/BinaryTree.cpp</a></p>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Common Knowledge of Camera</title>
    <url>/2020/Common-Knowledge-of-Camera/</url>
    <content><![CDATA[<h4 id="数码单镜头反光相机-DSLR-组成"><a href="#数码单镜头反光相机-DSLR-组成" class="headerlink" title="数码单镜头反光相机(DSLR)组成"></a>数码单镜头反光相机(DSLR)组成</h4><ul>
<li>五棱镜</li>
<li>取景器目镜</li>
<li>感光元件(CMOS)</li>
<li>快门</li>
<li>反光板</li>
</ul>
<h4 id="相机画幅"><a href="#相机画幅" class="headerlink" title="相机画幅"></a>相机画幅</h4><ul>
<li><strong>全画幅(36mm * 24mm):</strong> 感光元件大、成像质量好</li>
<li><strong>非全幅(23mm * 15mm, APS-C):</strong> 小型化、低成本</li>
</ul>
<h4 id="视角"><a href="#视角" class="headerlink" title="视角"></a>视角</h4><ul>
<li><p>从感光元件(像方焦平面)对角线的两端至镜头主点连线之间的夹角</p>
</li>
<li><p>视角角度的大小决定了被摄物体的成像范围</p>
</li>
</ul>
<h4 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h4><ul>
<li><p>照片的分辨率，像素越高，获得的照片尺寸越大</p>
</li>
<li><p>在相同的像素下，感光元件尺寸越大，单个像素的感光面积就越大，能捕获的光子就越多，记录的暗部细节和亮部细节就越丰富，其画质也就越好</p>
</li>
<li><p>相同尺寸的感光元件，其像素越高，单个像素的感光面积就越小，受到的干扰就越大，噪点也就越大，画质反而会下降</p>
</li>
</ul>
<h4 id="对焦系统"><a href="#对焦系统" class="headerlink" title="对焦系统"></a>对焦系统</h4><ul>
<li><strong>对焦点数:</strong> 取景器里所能看到的对焦点的数量，对焦点越多，构图越方便</li>
<li><strong>对焦精度:</strong> 十字型对焦点数的多少</li>
<li><strong>十字型:</strong> 对焦点对横、竖方向都敏感，对较准确</li>
<li><strong>一字型:</strong> 对焦点只对单向(纵、横)敏感，没有十字型对焦点准确</li>
</ul>
<h4 id="高感性能"><a href="#高感性能" class="headerlink" title="高感性能"></a>高感性能</h4><ul>
<li><p>感光度(ISO)越高，画面噪点越多，画质越差</p>
</li>
<li><p>高感光度性能的强弱对拍摄弱光环境下的题材尤为重要</p>
</li>
</ul>
<h4 id="连拍速度"><a href="#连拍速度" class="headerlink" title="连拍速度"></a>连拍速度</h4><ul>
<li><p>每秒拍摄照片的张数</p>
</li>
<li><p>连拍速度越快，越容易捕捉到精彩的瞬间</p>
</li>
</ul>
<h4 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h4><ul>
<li><strong>Av档:</strong> 光圈优先模式。在手动确定相机光圈的情况下，相机自动根据光圈值大小及当时环境找到最佳的快门速度，这种模式多用于拍摄人像及风光。我们知道光圈直接影响着景深，当我们拍摄人像需要浅景深时，就可以通过自定义大光圈，相机自动匹配快门速度，可以在很快情况下找到合适的曝光</li>
<li><strong>Tv档:</strong> 快门优先模式。即我们手动设置好快门速度，相机根据快门速度来确定最佳光圈值。快门优先模式一般用于拍摄运动的物体，例如体育比赛、水流、舞蹈中的人以及飞行中的物体等。拍摄运动物体最容易出现的问题是即使对了焦，照片也容易模糊，这是由于相机快门速度没有跟上被摄物体的运动速度导致的</li>
<li><strong>P档</strong>: 半自动档，与AUTO档不同的是它允许我们手动设置曝光补偿、ISO感光度等。在设置后相机自动匹配出最佳的光圈值和快门速度，特别适合用来抓拍。如果在暗光情况下使用P档，自动跳出的闪光灯可能会因为照射不到远处而导致远景过暗的情况，所以P档适合光线充足且摄距不远的情况下使用</li>
</ul>
]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title>Composition Rules</title>
    <url>/2020/Composition-Rules/</url>
    <content><![CDATA[<h4 id="构图目的"><a href="#构图目的" class="headerlink" title="构图目的"></a>构图目的</h4><ul>
<li><p>突出被摄主体: 观者的视线能被吸引到被摄主体上</p>
</li>
<li><p>画面简洁: 只保留必要元素，消除或减少分散观者注意力到元素</p>
</li>
</ul>
<h4 id="如何构图"><a href="#如何构图" class="headerlink" title="如何构图"></a>如何构图</h4><ul>
<li><strong>主体要突出</strong><ul>
<li>调整虚实</li>
<li>控制明暗</li>
<li>改变焦距</li>
</ul>
</li>
<li><strong>陪体有力衬托主体</strong><ul>
<li>渲染气氛</li>
<li>增加画面趣味性</li>
<li>与主题形成内容呼应</li>
<li>平衡画面，增加空间感</li>
</ul>
</li>
<li><strong>背景衬托</strong><ul>
<li>好的背景要简洁</li>
<li>好的背景可以交代环境信息，并与主体形成呼应</li>
</ul>
</li>
</ul>
<h4 id="构图方法"><a href="#构图方法" class="headerlink" title="构图方法"></a>构图方法</h4><ul>
<li><strong>三分构图法</strong><ul>
<li>横向(风光照片)<ul>
<li>天际线在画面上下方1/3</li>
</ul>
</li>
<li>竖向(人像照片)<ul>
<li>主体人物在左右侧1/3</li>
</ul>
</li>
</ul>
</li>
<li><strong>九宫格构图法</strong><ul>
<li>将需要表现的主体放在九宫格的4个交叉点上</li>
</ul>
</li>
<li><strong>线条构图法</strong><ul>
<li>曲线: 不呆板，延伸画面空间感<ul>
<li>小路 / 河流 / 女性身体曲线</li>
</ul>
</li>
<li>斜线: 力量与方向感，增强主体的气势和视觉冲击力<ul>
<li>运动体 / 人物身体线条</li>
</ul>
</li>
<li>汇聚线: 中心点<ul>
<li>视线 / 运动趋势</li>
</ul>
</li>
</ul>
</li>
<li><strong>形状构图法</strong><ul>
<li>三角形构图: 稳定性</li>
<li>弧线形构图: 柔美、生动</li>
<li>框架构图<ul>
<li>风光摄影: 修饰主题 / 浓缩远景 / 汇聚视线</li>
<li>人像摄影: 强化画面的空间感 / 丰富画面故事感</li>
<li>屋檐 / 门框 / 桥洞 / 树枝</li>
</ul>
</li>
</ul>
</li>
<li><strong>对称构图</strong><ul>
<li>将画面分割成对称的两部分: 平衡 / 稳定 / 相互呼应</li>
<li>庄重而平稳的建筑物 / 正面人像 / 倒影的场合</li>
<li>风光摄影: 水面的倒影</li>
<li>人像摄影: 一左一右对称</li>
</ul>
</li>
<li><strong>对比构图</strong><ul>
<li>突出主体，让照片更加戏剧化、富有艺术感染力</li>
<li>视觉反差强烈的色彩对比<ul>
<li>冷(蓝 / 绿): 使人后退</li>
<li>暖(黄 / 红): 使人前进</li>
</ul>
</li>
<li>影调丰富的明暗对比<ul>
<li>将视觉中心汇聚到画面中的明亮处，并增加空间感</li>
</ul>
</li>
<li>给人想象空间的虚实对比<ul>
<li>以虚映实，突出清晰的主体，并延伸空间感，创造画面故事感</li>
</ul>
</li>
<li>夸张效果的大小对比<ul>
<li>丰富视觉表现力</li>
</ul>
</li>
<li>画面舒展的疏密对比<ul>
<li>厚实 / 密不透风: 沉重和压抑</li>
<li>稀疏 / 松散: 轻松的自然美感</li>
<li>疏而不散 / 密而不乱: 松弛有度的节奏感和韵律感</li>
</ul>
</li>
<li>动感强烈的动静对比<ul>
<li>容易引起观看者的强烈关注</li>
<li>快门速度快(&gt;1/2s): 动静结合</li>
<li>快门速度慢(&lt;1/20s): 人影飘忽</li>
</ul>
</li>
</ul>
</li>
<li><strong>留白让照片更有想象空间</strong><ul>
<li>单一色调烘托画面意境，延伸画面空间</li>
<li>天空 / 水面 / 浓雾 / 草原 / 人物视线</li>
</ul>
</li>
<li><strong>善用前景营造唯美梦幻意境</strong><ul>
<li>虚化前景，实现梦幻的画面意境</li>
<li>树叶 / 花朵: 安排在画面的边缘</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY a VPN With SSR</title>
    <url>/2020/DIY-a-VPN-With-SSR/</url>
    <content><![CDATA[<p>Website: <a href="https://www.vultr.com/">https://www.vultr.com/</a></p>
<p>Software: Shadowsocks + Ubuntu OS</p>
<h4 id="Step-1-服务器端安装Shadowsocks"><a href="#Step-1-服务器端安装Shadowsocks" class="headerlink" title="Step 1. 服务器端安装Shadowsocks"></a>Step 1. 服务器端安装Shadowsocks</h4><p>服务端版本：Shadowsocks-Python， ShadowsocksR， Shadowsocks-Go， Shadowsocks-libev（四选一）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x shadowsocks-all.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span></span><br></pre></td></tr></table></figure>


<p>卸载方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./shadowsocks-all.sh uninstall</span></span><br></pre></td></tr></table></figure>


<h4 id="Step-2-各版本的启动脚本及配置文件名"><a href="#Step-2-各版本的启动脚本及配置文件名" class="headerlink" title="Step 2. 各版本的启动脚本及配置文件名"></a>Step 2. 各版本的启动脚本及配置文件名</h4><p>启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。</p>
<p>Shadowsocks-Python 版：</p>
<p>/etc/init.d/shadowsocks-python start | stop | restart | status</p>
<p>ShadowsocksR 版：</p>
<p>/etc/init.d/shadowsocks-r start | stop | restart | status</p>
<p>Shadowsocks-Go 版：</p>
<p>/etc/init.d/shadowsocks-go start | stop | restart | status</p>
<p>Shadowsocks-libev 版：</p>
<p>/etc/init.d/shadowsocks-libev start | stop | restart | status</p>
<p>各版本默认配置文件</p>
<p>Shadowsocks-Python 版：</p>
<p>/etc/shadowsocks-python/config.json</p>
<p>ShadowsocksR 版：</p>
<p>/etc/shadowsocks-r/config.json</p>
<p>Shadowsocks-Go 版：</p>
<p>/etc/shadowsocks-go/config.json</p>
<p>Shadowsocks-libev 版：</p>
<p>/etc/shadowsocks-libev/config.json</p>
<h4 id="Step-3-安装VPN加速器"><a href="#Step-3-安装VPN加速器" class="headerlink" title="Step 3. 安装VPN加速器"></a>Step 3. 安装VPN加速器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget <span class="string">&quot;https://github.com/chiakge/Linux-NetSpeed/raw/master/tcp.sh&quot;</span> &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</span></span><br></pre></td></tr></table></figure>


<p>安装 BBR</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span></span><br></pre></td></tr></table></figure>
<p>获取读写权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x bbr.sh</span></span><br></pre></td></tr></table></figure>
<p>启动BBR安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bbr.sh</span></span><br></pre></td></tr></table></figure>


<h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A?"></a>Q &amp; A?</h4><p>Q: 解决Host key verification failed</p>
<p>A: ssh-keygen -R 你要访问的IP地址</p>
]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>VPN</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title>EdgeMesh概述</title>
    <url>/2021/EdgeMesh%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>EdgeMesh is a part of KubeEdge, and provides a simple network solution for the inter-communications between services at edge scenarios.</p>
<h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h4><p>KubeEdge is build based on Kubernetes, extending cloud-native containerized application orchestration capabilities to the edge. However, at the scenario of edge computer, the network topology is more complex. Edge nodes in different areas are offen not interconnected, and the inter-communication of traffic between applications is the primary requirement of the business. For this scenairo, EdgeMesh offers a solution.</p>
<h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><p>As the component of data panel on a KubeEdge cluster, EdgeMesh offers sample capacities (e.g, service discovery, traffic proxy, etc.) for applications running on the KubeEdge cluster, thus shielding the complex network topology at the edge scenairo.</p>
<h4 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h4><p>EdgeMesh satisfies the new requirements in edge scenarios (e.g., limited edge resources, unstable edge cloud network, etc.), that is, high availability, high reliability, and extreme lightweight:</p>
<ul>
<li><strong>High availability</strong><ul>
<li>Open up the network between edge nodes by using the edge cloud channel in KubeEdge</li>
<li>Divide the communication between edge nodes into intra-LAN and cross-LAN<ul>
<li>Intra-LAN communication: direct access</li>
<li>Cross-LAN communication: forwarding through the cloud</li>
</ul>
</li>
</ul>
</li>
<li><strong>High reliability (offline scenario)</strong><ul>
<li>Both control plane and data plane traffic are delivered through the edge cloud channel</li>
<li>EdgeMesh internally implements a lightweight DNS server, thus no longer accessing the cloud DNS</li>
</ul>
</li>
<li><strong>Extreme lightweight</strong><ul>
<li>Each node has one and only one EdgeMesh, which saves edge resources</li>
</ul>
</li>
</ul>
<h5 id="User-value"><a href="#User-value" class="headerlink" title="User value"></a>User value</h5><ul>
<li>For edge devices with limited resources, EdgeMesh provides a lightweight and highly integrated software with service discovery</li>
<li>In the scene of Field Edge, compared to the mechanism of coredns + kube-proxy + cni service discovery , users only need to simply deploy an EdgeMesh to finish their goals</li>
</ul>
<h4 id="Key-Features"><a href="#Key-Features" class="headerlink" title="Key Features"></a>Key Features</h4><table align="center">
    <tr>
        <th align="center">Feature</th>
        <th align="center">Sub-Feature</th>
        <th align="center">Realization Degree</th>  
    </tr >
    <tr >
        <td align="center">Service Discovery</td>
        <td align="center">/</td>
        <td align="center">✓</td>
    </tr>
    <tr>
        <td rowspan="4" align="center">Traffic Governance</td>
         <td align="center">HTTP</td>
        <td align="center">✓</td>
    </tr>
    <tr>
         <td align="center">TCP</td>
        <td align="center">✓</td>
    </tr>
    <tr>
         <td align="center">Websocket</td>
        <td align="center">✓</td>
    </tr>
    <tr>
         <td align="center">HTTPS</td>
        <td align="center">✓</td>
    </tr>
    <tr>
        <td rowspan="3" align="center">Load Balance</td>
         <td align="center">Random</td>
        <td align="center">✓</td>
    </tr>
    <tr>
         <td align="center">Round Robin</td>
        <td align="center">✓</td>
    </tr>
    <tr>
        <td align="center">Session Persistence</td>
        <td align="center">✓</td>
    </tr>
    <tr>
        <td align="center">External Access</td>
        <td align="center">/</td>
        <td align="center">✓</td>
    </tr>
    <tr>
        <td align="center">Multi-NIC Monitoring</td>
        <td align="center">/</td>
        <td align="center">✓</td>
    </tr>
  <tr>
        <td rowspan="2" align="center">Cross-Subnet Communication</td>
         <td align="center">Cross-Cloud Communication</td>
        <td align="center">+</td>
    </tr>
    <tr>
         <td align="center">Cross-LAN E2E Communication</td>
        <td align="center">+</td>
    </tr>
  <tr>
        <td align="center">Edge CNI</td>
         <td align="center">Cross-Subnet Pod Communication</td>
        <td align="center">+</td>
    </tr>
</table>



<p><strong>Noting:</strong></p>
<ul>
<li><code>✓</code> Features supported by the EdgeMesh version </li>
<li><code>+</code> Features not available in the EdgeMesh version, but will be supported in subsequent versions</li>
<li><code>-</code> Features not available in the EdgeMesh version, or deprecated features</li>
</ul>
<h4 id="Future-Works"><a href="#Future-Works" class="headerlink" title="Future Works"></a>Future Works</h4><img src="/images/kube/em-intro.png" style="zoom:80%;" />

<p>At present, the implementation of EdgeMesh relies on the connectivity of the host network. In the future, EdgeMesh will realize the capabilities of CNI plug-ins, and realize the Pod network connectivity between edge nodes and nodes on the cloud, or edge nodes across LANs in a  compatible manner with mainstream CNI plug-ins (e.g., flannel / calico, etc). Finally, EdgeMesh can even replace part of its own components with cloud-native components (e.g., replacing <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> to achieve the capabilities of the Cluster IP, replacing <a href="https://kubernetes.io/docs/tasks/administer-cluster/nodelocaldns/">node local dns cache </a> to achieve node-level dns capabilities, and replace <a href="https://www.envoyproxy.io/">envoy</a> to achieve mesh-layer capabilities).</p>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><img src="/images/kube/em-arch.png" style="zoom:67%;" />

<p>To ensure the capability of service discovery in some edge devices with low-version kernels or low-version iptables, EdgeMesh adopts the userspace mode in its implementation of the traffic proxy. In addition, it also comes with a lightweight DNS resolver. As shown in the figure above, the core components of EdgeMesh include:</p>
<ul>
<li><strong>Proxier</strong>: Responsible for configuring the kernel’s iptables rules, and intercepting requests to the EdgeMesh process</li>
<li><strong>DNS</strong>: Built-in DNS resolver, which resolves the DNS request in the node into a service cluster IP</li>
<li><strong>Traffic</strong>: A traffic forwarding module based on the Go-chassis framework, which is responsible for forwarding traffic between applications</li>
<li><strong>Controller</strong>: Obtains metadata (e.g., Service, Endpoints, Pod, etc.) through the list-watch capability on the edge side of KubeEdge</li>
</ul>
<h4 id="How-It-Works"><a href="#How-It-Works" class="headerlink" title="How It Works"></a>How It Works</h4><ul>
<li>Through the capability of list-watch on the edge of KubeEdge, EdgeMesh monitors the addition, deletion and modification of metadata (e.g., Services and Endpoints), and then creates iptables rules based on Services and Endpoints</li>
<li>EdgeMesh uses the same ways (e.g., Cluster IP, domain name) as the K8s Service to access services</li>
<li>When client’s requests accessing a service reach a node with EdgeMesh, it will enter the kernel’s iptables at first</li>
<li>The iptables rules previously configured by EdgeMesh will redirect requests, and forward them all to the port 40001 which is occupied by the EdgeMesh process (data packets from kernel mode to user mode)</li>
<li>After requests enter the EdgeMesh process, the EdgeMesh process completes the selection of backend Pods (load balancing occurs here), and then sends requests to the host where the Pod is located</li>
</ul>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h4 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h4><p>Before using EdgeMesh, you need to understand the following prerequisites at first:</p>
<ul>
<li>when using edgemesh’s capabilities, the Pod is required a hostPort (as shown in following examples)</li>
<li>while using DestinationRule, the name of the DestinationRule must be equal to the name of the corresponding Service. Edgemesh will determine the DestinationRule in the same namespace according to the name of the Service</li>
<li>Service ports must be named. The key/value pairs of port name must have the following syntax: name: &lt;protocol&gt;[-&lt;suffix&gt;]</li>
</ul>
<h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><p>At the edge node, close EdgeMesh, open metaserver, and restart edgecore</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/kubeedge/config/edgecore.yaml</span></span><br><span class="line">modules:</span><br><span class="line">  ..</span><br><span class="line">  edgeMesh:</span><br><span class="line">    enable: false</span><br><span class="line">  metaManager:</span><br><span class="line">    metaServer:</span><br><span class="line">      enable: true</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl restart edgecore</span></span><br></pre></td></tr></table></figure>
<p>On the cloud, open the dynamic controller module, and restart cloudcore</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/kubeedge/config/cloudcore.yaml</span></span><br><span class="line">modules:</span><br><span class="line">  ..</span><br><span class="line">  dynamicController:</span><br><span class="line">    enable: true</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<p>At the edge node, check if list-watch works</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl 127.0.0.1:10550/api/v1/services</span></span><br><span class="line">&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;items&quot;:[&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:&#123;&quot;creationTimestamp&quot;:&quot;2021-04-14T06:30:05Z&quot;,&quot;labels&quot;:&#123;&quot;component&quot;:&quot;apiserver&quot;,&quot;provider&quot;:&quot;kubernetes&quot;&#125;,&quot;name&quot;:&quot;kubernetes&quot;,&quot;namespace&quot;:&quot;default&quot;,&quot;resourceVersion&quot;:&quot;147&quot;,&quot;selfLink&quot;:&quot;default/services/kubernetes&quot;,&quot;uid&quot;:&quot;55eeebea-08cf-4d1a-8b04-e85f8ae112a9&quot;&#125;,&quot;spec&quot;:&#123;&quot;clusterIP&quot;:&quot;10.96.0.1&quot;,&quot;ports&quot;:[&#123;&quot;name&quot;:&quot;https&quot;,&quot;port&quot;:443,&quot;protocol&quot;:&quot;TCP&quot;,&quot;targetPort&quot;:6443&#125;],&quot;sessionAffinity&quot;:&quot;None&quot;,&quot;type&quot;:&quot;ClusterIP&quot;&#125;,&quot;status&quot;:&#123;&quot;loadBalancer&quot;:&#123;&#125;&#125;&#125;,&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&quot;prometheus.io/port&quot;:&quot;9153&quot;,&quot;prometheus.io/scrape&quot;:&quot;true&quot;&#125;,&quot;creationTimestamp&quot;:&quot;2021-04-14T06:30:07Z&quot;,&quot;labels&quot;:&#123;&quot;k8s-app&quot;:&quot;kube-dns&quot;,&quot;kubernetes.io/cluster-service&quot;:&quot;true&quot;,&quot;kubernetes.io/name&quot;:&quot;KubeDNS&quot;&#125;,&quot;name&quot;:&quot;kube-dns&quot;,&quot;namespace&quot;:&quot;kube-system&quot;,&quot;resourceVersion&quot;:&quot;203&quot;,&quot;selfLink&quot;:&quot;kube-system/services/kube-dns&quot;,&quot;uid&quot;:&quot;c221ac20-cbfa-406b-812a-c44b9d82d6dc&quot;&#125;,&quot;spec&quot;:&#123;&quot;clusterIP&quot;:&quot;10.96.0.10&quot;,&quot;ports&quot;:[&#123;&quot;name&quot;:&quot;dns&quot;,&quot;port&quot;:53,&quot;protocol&quot;:&quot;UDP&quot;,&quot;targetPort&quot;:53&#125;,&#123;&quot;name&quot;:&quot;dns-tcp&quot;,&quot;port&quot;:53,&quot;protocol&quot;:&quot;TCP&quot;,&quot;targetPort&quot;:53&#125;,&#123;&quot;name&quot;:&quot;metrics&quot;,&quot;port&quot;:9153,&quot;protocol&quot;:&quot;TCP&quot;,&quot;targetPort&quot;:9153&#125;],&quot;selector&quot;:&#123;&quot;k8s-app&quot;:&quot;kube-dns&quot;&#125;,&quot;sessionAffinity&quot;:&quot;None&quot;,&quot;type&quot;:&quot;ClusterIP&quot;&#125;,&quot;status&quot;:&#123;&quot;loadBalancer&quot;:&#123;&#125;&#125;&#125;],&quot;kind&quot;:&quot;ServiceList&quot;,&quot;metadata&quot;:&#123;&quot;resourceVersion&quot;:&quot;377360&quot;,&quot;selfLink&quot;:&quot;/api/v1/services&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Build EdgeMesh image (not necessary)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t edgemesh:0.1 -f build/Dockerfile .</span></span><br></pre></td></tr></table></figure>
<p>Deploy EdgeMesh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Please <span class="built_in">set</span> the subNet to the value of service-cluster-ip-range of kube-apiserver.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can obtain the value from the /etc/kubernetes/manifests/kube-apiserver.yaml file on the master node</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f build/kubernetes/edgemesh/03-configmap.yaml</span></span><br><span class="line">configmap/edgemesh-cfg created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f build/kubernetes/edgemesh/04-daemonset.yaml</span></span><br><span class="line">daemonset.apps/edgemesh created</span><br></pre></td></tr></table></figure>


<h4 id="Test-Case"><a href="#Test-Case" class="headerlink" title="Test Case"></a>Test Case</h4><p><strong>HTTP</strong></p>
<p>At the edge node, deploy a HTTP container application, and relevant service</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f example/hostname.yaml</span></span><br></pre></td></tr></table></figure>
<p>Go to that edge node, use ‘curl’ to access the service, and print out the hostname of the container</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl hostname-lb-svc.edgemesh-test:12345</span></span><br></pre></td></tr></table></figure>


<p><strong>TCP</strong></p>
<p>At the edge node 1, deploy a TCP container application, and relevant service    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f example/tcp-echo-service.yaml</span></span><br></pre></td></tr></table></figure>
<p>At the edge node 1, use ‘telnet’ to access the service        </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> telnet tcp-echo-service.edgemesh-test 2701</span></span><br></pre></td></tr></table></figure>


<p><strong>Websocket</strong></p>
<p>At the edge node 1, deploy a websocket container application, and relevant service    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f example/websocket-pod-svc.yaml</span></span><br></pre></td></tr></table></figure>
<p>Enter the container, and use ./client to access the service</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it 2a6ae1a490ae bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./client --addr ws-svc.edgemesh-test:12348</span></span><br></pre></td></tr></table></figure>


<p><strong>Load Balance</strong></p>
<p>The capability of load balance needs to add the CRD ‘DestinationRule’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f build/istio/destinationrule-crd.yaml</span></span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/destinationrules.networking.istio.io created</span><br></pre></td></tr></table></figure>
<p>Use the ‘loadBalancer’ in ‘DestinationRule’ to select LB modes    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim example/hostname-lb-random.yaml</span></span><br><span class="line">spec</span><br><span class="line">..</span><br><span class="line">  trafficPolicy:</span><br><span class="line">    loadBalancer:</span><br><span class="line">      simple: RANDOM</span><br><span class="line">..    </span><br></pre></td></tr></table></figure>


<h2 id="EdgeMesh-Ingress-Gateway"><a href="#EdgeMesh-Ingress-Gateway" class="headerlink" title="EdgeMesh Ingress Gateway"></a>EdgeMesh Ingress Gateway</h2><p>EdgeMesh ingress gateway provides a ability to access services in external edge nodes.</p>
<p><img src="/images/fs/em-ig.png"></p>
<h4 id="HTTP-Gateway"><a href="#HTTP-Gateway" class="headerlink" title="HTTP Gateway"></a>HTTP Gateway</h4><p>Create two CRDs: ‘Gateway’ and ‘VirtualService’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f build/istio/gateway-crd.yaml</span></span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/gateways.networking.istio.io created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f build/istio/virtualservice-crd.yaml</span></span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/virtualservices.networking.istio.io created</span><br></pre></td></tr></table></figure>
<p>Deploy edgemesh-gateway</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f 03-configmap.yaml</span> </span><br><span class="line">configmap/edgemesh-gateway-cfg created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f 04-deployment.yaml</span> </span><br><span class="line">deployment.apps/edgemesh-gateway created</span><br></pre></td></tr></table></figure>
<p>Create ‘Gateway’ and ‘VirtualService’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f example/hostname-lb-random-gateway.yaml</span></span><br><span class="line">pod/hostname-lb-edge2 created</span><br><span class="line">pod/hostname-lb-edge3 created</span><br><span class="line">service/hostname-lb-svc created</span><br><span class="line">gateway.networking.istio.io/edgemesh-gateway configured</span><br><span class="line">destinationrule.networking.istio.io/hostname-lb-edge created</span><br><span class="line">virtualservice.networking.istio.io/edgemesh-gateway-svc created</span><br></pre></td></tr></table></figure>
<p>Check if the edgemesh-gateway is successfully deployed</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get gw -n edgemesh-test</span></span><br><span class="line">NAME               AGE</span><br><span class="line">edgemesh-gateway   3m30s</span><br></pre></td></tr></table></figure>
<p>Finally, use the IP and the port exposed by the VirtualService to access</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl 192.168.0.211:12345</span></span><br></pre></td></tr></table></figure>


<h4 id="HTTPS-GateWay"><a href="#HTTPS-GateWay" class="headerlink" title="HTTPS GateWay"></a>HTTPS GateWay</h4><p>Create a test key file</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj <span class="string">&quot;/CN=kubeedge.io&quot;</span></span><br><span class="line">Generating a RSA private key</span><br><span class="line">............+++++</span><br><span class="line">.......................................................................................+++++</span><br><span class="line">writing new private key to <span class="string">&#x27;tls.key&#x27;</span></span><br><span class="line">-----</span><br></pre></td></tr></table></figure>
<p>Create a ‘Secret’ according to the key file</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create secret tls gw-secret --key tls.key --cert tls.crt -n edgemesh-test</span><br><span class="line">secret/gw-secret created</span><br></pre></td></tr></table></figure>
<p>Create a Secret-bound ‘Gateway’ and routing rules ‘VirtualService’</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f example/hostname-lb-random-gateway-tls.yaml</span><br><span class="line">pod/hostname-lb-edge2 created</span><br><span class="line">pod/hostname-lb-edge3 created</span><br><span class="line">service/hostname-lb-svc created</span><br><span class="line">gateway.networking.istio.io/edgemesh-gateway configured</span><br><span class="line">destinationrule.networking.istio.io/hostname-lb-edge created</span><br><span class="line">virtualservice.networking.istio.io/edgemesh-gateway-svc created</span><br></pre></td></tr></table></figure>
<p>Finally, use the certificate for a HTTPS access</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -k --cert ./tls.crt --key ./tls.key https://192.168.0.129:12345</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/xiaoli777/edgemesh">https://github.com/xiaoli777/edgemesh</a></p>
<p><a href="https://docs.kubeedge.io/en/docs/advanced/edgemesh/">https://docs.kubeedge.io/en/docs/advanced/edgemesh/</a></p>
<p><a href="https://www.bilibili.com/video/BV18i4y1N7SV">https://www.bilibili.com/video/BV18i4y1N7SV</a></p>
]]></content>
      <categories>
        <category>Edge Computing</category>
      </categories>
      <tags>
        <tag>KubeEdge</tag>
        <tag>ServiceMesh</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB Installation on Mac OS</title>
    <url>/2021/GDB-Installation-on-Mac-OS/</url>
    <content><![CDATA[<h4 id="Step-1-Install-gdb"><a href="#Step-1-Install-gdb" class="headerlink" title="Step 1. Install gdb"></a>Step 1. Install gdb</h4><ol>
<li><p>To install gdb by the following command on terminal:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install gdb</span></span><br></pre></td></tr></table></figure></li>
<li><p>We can confirm whether gdb is installed successfully by running:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb --version</span></span><br></pre></td></tr></table></figure>
<p>On my Mac, we can see:</p>
<img src="/images/config/gdbversion.png" alt="gdbversion" style="zoom:67%;" />
</li>
<li><p>However, we will get the information as follows while try to run a program:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Unable to find Mach task port for process-id XXXXX: (os/kern) failure (0x5).</span><br><span class="line">(please check gdb is codesigned - see taskgated(8))</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="Step-2-Create-a-Certificate"><a href="#Step-2-Create-a-Certificate" class="headerlink" title="Step 2. Create a Certificate"></a>Step 2. Create a Certificate</h4><ol>
<li><p>Open Launchpad -&gt; Other -&gt;  Keychain Access</p>
</li>
<li><p>In its menu, open Keychain Access -&gt; Certificate Assistant -&gt; Create a certificate</p>
</li>
<li><p>While creating, we set Identity type to Self Signed Root, Certificate type to Code Signing, and check “let me override defaults”. </p>
<img src="/images/config/creategdbcert.png" alt="creategdbcert" style="zoom:67%;" />
</li>
<li><p>We just continue until we get a page which prompts us for “specify a location”, and select Keychain location to System. Then, create a certificate and close assistant.</p>
<p>Noting: If we get an error as follows, we need to repeat the whole Step 2, but set Keychain location to Login in 4.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Unknown Error = -2,147,414,007</span><br></pre></td></tr></table></figure></li>
<li><p>Find the certificate we just created, and double click it. Then, modify Trust, set Code Signing to Always Trust.</p>
<img src="/images/config/gdbtrust.png" alt="gdbtrust" style="zoom:67%;" />
</li>
<li><p>Restart taskgated in terminal by running:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo killall taskgated</span></span><br></pre></td></tr></table></figure></li>
<li><p>Create a file called gdb-entitlement.xml which allows OS to trust gdb for debugging:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim gdb-entitlement.xml</span></span><br></pre></td></tr></table></figure>
<p>which includes:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="meta-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.cs.allow-jit<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.cs.allow-unsigned-executable-memory<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.cs.allow-dyld-environment-variables<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.cs.disable-library-validation<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.cs.disable-executable-page-protection<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.cs.debugger<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.get-task-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Run codesign on terminal: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> codesign --entitlements gdb-entitlement.xml -fs gdb-cert /usr/<span class="built_in">local</span>/bin/gdb</span></span><br></pre></td></tr></table></figure>
<p>And, we will ask for inputting the root password.</p>
</li>
<li><p>Finally, reboot!</p>
</li>
</ol>
<h4 id="Step-3-Runing-gdb"><a href="#Step-3-Runing-gdb" class="headerlink" title="Step 3. Runing gdb"></a>Step 3. Runing gdb</h4><ol>
<li><p>Create HelloWorld.c using C:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Compile it with -g option:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc HelloWorld.c -g -o HelloWorld</span></span><br></pre></td></tr></table></figure></li>
<li><p>Run gdb to debug this program. Successfully!!!</p>
<img src="/images/config/gdbdebug.png" alt="gdbdebug" style="zoom:67%;" />

<p>Noting, if we find the following information, and the debugger is stopped:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[New Thread 0x1a03 of process 3822]</span><br></pre></td></tr></table></figure>
<p>We need to type the following into the terminal, and restart a debugger:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;set startup-with-shell off&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>C Language</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction to Camera Lens</title>
    <url>/2020/Introduction-to-Camera-Lens/</url>
    <content><![CDATA[<h4 id="相机镜头介绍"><a href="#相机镜头介绍" class="headerlink" title="相机镜头介绍"></a>相机镜头介绍</h4><ul>
<li><p><strong>装卸方法:</strong> 将机身镜头卡口朝下，迅速更换镜头</p>
<ul>
<li>取下机身盖和镜头的后盖，准备安装镜头</li>
<li>将镜头的红色标志与机身的红色标志对齐，缓慢、平稳地将镜头安装与机身</li>
<li>镜身插入机身后，沿顺时针方向(面向相机正面)旋转镜头，听到“咔”的声音，说明安装的镜头已锁定</li>
</ul>
</li>
</ul>
<h4 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h4><ul>
<li><p><strong>口径:</strong> 相机镜头前端的螺纹口径</p>
</li>
<li><p><strong>光圈:</strong> 控制光线进入镜头的装置，光圈大小以F值表示</p>
<ul>
<li>恒定光圈: F4G指每一个焦段都可以使用最大为F4的光圈值来拍摄</li>
<li>浮动光圈: F4-5.6指焦距变化时，最大光圈也在F4和F5.6之间进行变化</li>
<li>通常情况下，光圈越大越好，恒定光圈比浮动光圈好</li>
</ul>
</li>
<li><p><strong>焦距:</strong> 定焦镜头 / 变焦镜头</p>
<ul>
<li><p><strong>最近对焦距离</strong></p>
<ul>
<li>镜头可以对焦的最短距离，镜头无法在短于最小对焦距离的位置对焦</li>
<li>测量与拍摄对象间的距离是从相机机身上的焦平面标记开始而不是从相机前部开始</li>
</ul>
</li>
<li><p><strong>焦距不同带来画面视角的差异(相机位置不变)</strong></p>
<ul>
<li>焦距越长(200mm)，视角越窄，拍进画面的景物范围也越窄，被摄体成像就会越大</li>
<li>焦距越短(100mm)，视角越广，拍进画面的景物范围也越广，被摄体成像就会越小</li>
</ul>
<img src="/images/photo/ViewFromFocus.png" alt="ViewFromFocus" style="zoom:67%;" />
</li>
<li><p><strong>焦距不同带来画面纵深感的差异(被摄体大小不变)</strong></p>
<ul>
<li>焦距越长(200mm)，拍进画面的范围越窄，视觉上被摄体离背景更近，纵深感更弱</li>
<li>焦距越短(100mm)，拍进画面的范围越宽，视觉上被摄体离背景更远，纵深感更强</li>
</ul>
<img src="/images/photo/LayerFromFocus.png" alt="LayerFromFocus" style="zoom:67%;" />
</li>
</ul>
</li>
<li><p><strong>防抖:</strong> 通过一组矫正镜组对因抖动产生的光路偏移进行矫正，防止成像模糊的问题</p>
</li>
</ul>
<h4 id="镜头选择"><a href="#镜头选择" class="headerlink" title="镜头选择"></a>镜头选择</h4><ul>
<li>变焦镜头由于要控制镜头的体积和重量，因此在画质上有所妥协，成像效果不及同规格的定焦镜头</li>
<li>定焦镜头具备更大的光圈，非常适合拍摄背景虚化的人像照片和弱光环境下的星空题材</li>
<li><strong>广角镜头(14<del>20mm 或 24</del>38mm):</strong><ul>
<li>视野宽阔，比人眼看到的景物范围大得多，同时具备大景深的特点，可以将远景和近景都拍摄得很清楚。广角镜头能强调画面的透视效果，并且善于夸张前景和表象景物的远近感</li>
</ul>
</li>
<li><strong>人物纪实(35mm):</strong><ul>
<li>透视变形不严重的小广角镜头</li>
</ul>
</li>
<li><strong>标准镜头(40~55mm):</strong><ul>
<li>接近人眼看到的景象，其透视关系接近于人眼所感觉到的透视关系，所以能够逼真地再现被摄物体的真实特征</li>
</ul>
</li>
<li><strong>中焦镜头(85mm 或 105mm 或 135mm):</strong><ul>
<li>变形效果小，配合大光圈可以获得极佳的背景虚化效果</li>
</ul>
</li>
<li><strong>长变焦镜头(70~200mm):</strong><ul>
<li>具备望远功能，可以压缩画面的空间感</li>
</ul>
</li>
<li><strong>微距镜头:</strong><ul>
<li>能把主体的细节纤毫毕现地表现出来，主要用于拍摄十分微小的物体</li>
</ul>
</li>
<li><strong>鱼眼镜头:</strong><ul>
<li>180度超大广角，会导致桶形畸变</li>
</ul>
</li>
<li><strong>移轴镜头:</strong><ul>
<li>可实现倾角与偏移功能的特殊镜头，其主要目的是调整透视变形。通过使用倾角与偏移功能像各种角度和位置转动镜头，可以移动合焦面或对被摄体的形状进行补偿。主要用于建筑摄影和广告摄影</li>
</ul>
</li>
<li><strong>UV镜:</strong><ul>
<li>紫外线滤光镜，主要作用是保护镜头，同时能过滤紫外线(有助于提高成像清晰度和色彩效果)</li>
</ul>
</li>
<li><strong>偏光镜PL:</strong><ul>
<li>偏振镜，它利用偏振光的特性，把非金属物体、水面等被摄物体的反光进行过滤消除，使成像色彩更加鲜艳。PL分为圆偏光镜(CPL)和线性偏光镜(LPL)</li>
</ul>
</li>
<li><strong>中灰滤镜:</strong><ul>
<li>ND镜，中灰密度镜，仅一块灰色纯透明的光学玻璃，其目的是减少进入镜头的通光量，从而有效降低曝光量</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title>KubeEdge Beehive</title>
    <url>/2021/KubeEdge-Beehive/</url>
    <content><![CDATA[<p>下载地址：<a href="https://github.com/kubeedge/kubeedge">https://github.com/kubeedge/kubeedge</a></p>
<p>版本：<a href="https://github.com/kubeedge/kubeedge/releases/tag/v1.5.0">KubeEdge v1.5.0 release</a></p>
]]></content>
      <categories>
        <category>Edge Computing</category>
      </categories>
      <tags>
        <tag>KubeEdge</tag>
        <tag>Go</tag>
        <tag>Containerization</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes Installation</title>
    <url>/2021/Kubernetes-Installation/</url>
    <content><![CDATA[<h2 id="机器配置"><a href="#机器配置" class="headerlink" title="机器配置"></a>机器配置</h2><table>
<thead>
<tr>
<th>主机名</th>
<th>角色</th>
<th>IP</th>
<th>系统</th>
</tr>
</thead>
<tbody><tr>
<td>centos-istio-0001</td>
<td>Slave</td>
<td>159.138.51.216</td>
<td>CentOS 8.2 64bit</td>
</tr>
<tr>
<td>centos-istio-0002</td>
<td>Slave</td>
<td>159.138.57.247</td>
<td>CentOS 8.2 64bit</td>
</tr>
<tr>
<td>centos-istio-0003</td>
<td>Master</td>
<td>182.160.9.140</td>
<td>CentOS 8.2 64bit</td>
</tr>
</tbody></table>
<p>注⚠️：三台机器均已安装Docker。</p>
<h2 id="允许-iptables-检查桥接流量"><a href="#允许-iptables-检查桥接流量" class="headerlink" title="允许 iptables 检查桥接流量"></a>允许 iptables 检查桥接流量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>


<h2 id="安装-kubeadm、kubelet-和-kubectl"><a href="#安装-kubeadm、kubelet-和-kubectl" class="headerlink" title="安装 kubeadm、kubelet 和 kubectl"></a>安装 kubeadm、kubelet 和 kubectl</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">repo_gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">exclude=kubelet kubeadm kubectl</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> --now kubelet</span><br></pre></td></tr></table></figure>
<p>查看kubelet、kubeadm和kubectl是否安装成功</p>
<p><img src="/images/kube/kube-1.png"></p>
<h2 id="使用kubeadm安装master集群"><a href="#使用kubeadm安装master集群" class="headerlink" title="使用kubeadm安装master集群"></a>使用kubeadm安装master集群</h2><p><img src="/images/kube/kube-2.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address=192.168.0.96 --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/kube-3.png"></p>
<p>要使非 root 用户可以运行 kubectl，请运行以下命令， 它们也是 <code>kubeadm init</code> 输出的一部分：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>
<p>或者，如果你是 <code>root</code> 用户，则可以运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>


<h2 id="安装flannel网络"><a href="#安装flannel网络" class="headerlink" title="安装flannel网络"></a>安装flannel网络</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/kube-4.png"></p>
<h2 id="将Slave节点加入集群"><a href="#将Slave节点加入集群" class="headerlink" title="将Slave节点加入集群"></a>将Slave节点加入集群</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.0.96:6443 --token 8axber.2vzp1am4kcr7qpxd \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:10e0a25cc62687435f0211feeea1896d1ea512f3233a258ab0ef56a921224436</span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/kube-5.png"></p>
<h2 id="查看集群节点状态"><a href="#查看集群节点状态" class="headerlink" title="查看集群节点状态"></a>查看集群节点状态</h2><p><img src="/images/kube/kube-6.png"></p>
]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>Containerization</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux GoLang</title>
    <url>/2021/Linux-GoLang/</url>
    <content><![CDATA[<h3 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1. 下载安装包"></a>1. 下载安装包</h3><p>在Go语言下载官网 <a href="https://golang.org/dl/">https://golang.org/dl/</a> ，下载所需的Linux安装包</p>
<p><img src="/images/go/go-5.png"></p>
<h3 id="2-上传并解压"><a href="#2-上传并解压" class="headerlink" title="2. 上传并解压"></a>2. 上传并解压</h3><p>将下载的tar.gz包上传到Linux机器上，并使用<strong>tar -zxvf go1.16.2.linux-amd64.tar.gz</strong>解压</p>
<p><img src="/images/go/go-6.png"></p>
<h3 id="3-拷贝到-usr-local下"><a href="#3-拷贝到-usr-local下" class="headerlink" title="3. 拷贝到/usr/local下"></a>3. 拷贝到/usr/local下</h3><p>通过<strong>mv go /usr/local/go</strong>，将解压后的文件夹拷贝到/user/local下</p>
<p><img src="/images/go/go-7.png"></p>
<h3 id="4-查看go的版本号"><a href="#4-查看go的版本号" class="headerlink" title="4. 查看go的版本号"></a>4. 查看go的版本号</h3><p><img src="/images/go/go-8.png"></p>
<h3 id="5-设置环境变量"><a href="#5-设置环境变量" class="headerlink" title="5. 设置环境变量"></a>5. 设置环境变量</h3><p>编辑/etc/profile文件，并加入如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> GOPATH=~/golib:~/goproject</span><br><span class="line"><span class="built_in">export</span> GBIN=~/gobin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin/:<span class="variable">$GOBIN</span></span><br></pre></td></tr></table></figure>
<p>执行source /etc/profile命令使得环境变量生效</p>
<p><img src="/images/go/go-9.png"></p>
]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>OverlayFS -- A Container File System</title>
    <url>/2021/OverlayFS-A-Container-File-System/</url>
    <content><![CDATA[<h2 id="基本概念和特征"><a href="#基本概念和特征" class="headerlink" title="基本概念和特征"></a>基本概念和特征</h2><p>Docker容器最常用的文件系统是AUFS, 但随着Linux Kernel 3.18把Overlay纳入其中后，Overlay文件系统的地位就变得尤为重要。目前，Docker默认的存储文件系统是Overlay，相比于AUFS，其速度更快，实现也更为简单。</p>
<p>Overlay文件系统将不同的目录(底层目录和高层目录)划分为不同的层次，并通过联合挂载过程将数个高、底层目录合并成一个统一的目录，即统一合并视图层。如下图所示，在Docker与Overlay文件系统的分层图中，只读镜像层是底层目录，读写容器层是高层目录，而容器运行实际的应用层是统一合并视图层。</p>
<img src="/images/fs/overlayarch.png" alt="overlayarch" style="zoom:67%;" />

<p>在Overlay文件系统中，用户只能看到存在于统一合并视图层中的目录和文件，但这些目录和文件既可能来自于高层目录，也可能来自于底层目录。因此，当用户查看统一合并视图层的目录或文件时，用户会感觉到上下层同名目录合并和上下层同名文件覆盖：</p>
<ol>
<li><p><strong>上下层同名目录合并：</strong>如果某个目录并不是仅来自单独的一层(仅高层目录或底层目录)，它会逐级遍历(从高层目录到底层目录，再到更低的底层目录)扫描所有层中的同名目录，然后将同名目录中的内容合并后，返回给用户唯一一个包含全部内容的同名目录。</p>
</li>
<li><p><strong>上下层同名文件覆盖：</strong>如果在遍历扫描过程中发现同名文件，Overlay文件系统会优先向用户呈现较高层中的文件，即忽略来自底层目录的文件而只显示来自高层目录的文件，或者忽略来自较低底层目录的文件而显示来自更高底层目录的文件。</p>
</li>
</ol>
<p>值得注意的是，高层目录和底层目录中文件的存储和组织方式是基于宿主机文件系统，即Ext4文件系统，而不是基于Overlay文件系统。Overlay文件系统提供的功能仅是将数个目录层联合挂载到统一合并视图层，并提供相应的文件访问接口。</p>
<h2 id="基本文件操作"><a href="#基本文件操作" class="headerlink" title="基本文件操作"></a>基本文件操作</h2><p>在Overlay文件系统中，用户视角只能看到统一合并视图层的内容。因此，用户相应的Overlay基本文件操作(如文件创建、删除、读取、写入等)也都起始于统一合并视图层。然而，统一合并视图层仅提供实际文件的视图，并不存储和组织实际的文件(存储在属于Ext4文件系统的高层目录和底层目录中)。因此，当统一合并视图层的基本文件操作发生时，Overlay文件系统通过自身文件系统定义的函数接口找到操作对象在高层目录和底层目录对应的实际文件，然后将控制权转移给Ext4文件系统，最后通过VFS进一步调用操作系统定义的文件操作。而这个跨层文件的转换过程被称为文件重定向(file redirection)。</p>
<p>Overlay文件系统的基本文件操作包括<strong>文件读取、文件写入、文件创建</strong>和<strong>文件删除</strong>。但是根据不同的操作类型和实际文件所在的层次，Overlay文件系统会分别采取不同的处理策略：</p>
<h4 id="1-文件读取操作"><a href="#1-文件读取操作" class="headerlink" title="1) 文件读取操作"></a>1) 文件读取操作</h4><p><strong>场景1.</strong> 文件和目录只存在于底层目录，却不存在于高层目录：Overlay文件系统通过视图层的文件和目录的目录项，使用文件重定向找到其在底层目录中对应的实际目录项与索引节点，接着将操作的控制权转交给VFS，并由VFS进一步执行操作系统已定义好的读取操作；</p>
<p><strong>场景2.</strong> 文件和目录只存在于高层目录，却不存在于底层目录：与场景1的过程基本相同，唯有通过文件重定向找到在高层目录中对应的实际目录项(real_dentry)与索引节点，再将控制权转交给VFS；</p>
<p><strong>场景3.</strong> 文件和目录同时存在于高层目录和底层目录：由于Overlay文件系统的视图层会用高层目录中的文件覆盖底层目录中的文件，所以读取过程和场景2相同。</p>
<h4 id="2-文件写入操作"><a href="#2-文件写入操作" class="headerlink" title="2) 文件写入操作"></a>2) 文件写入操作</h4><p><strong>场景1.</strong> 文件和目录是首次写入，仅存在于底层目录，且不存在于高层目录中：Overlay文件系统通过文件重定向找到底层目录中的实际文件，再执行写时复制(Copy-on-Write, CoW)，将对象从底层目录拷贝到高层目录；然后，将复制后的目录和文件的目录项和控制权转交给VFS；接着，VFS进一步执行宿主机文件系统已定义的文件写入操作，读取拷贝的文件和目录并修改，再将修改后的结果保存在高层目录。值得注意的是，Overlay属于文件级别的文件系统：即使文件只有很小一部分的修改，也会触发写时复制；</p>
<p><strong>场景2.</strong> 文件和目录是首次写入，但存在于高层目录：与场景1处理基本相同，但不会发生写时复制(Copy-on-Write)。Overlay文件系统仅通过文件重定向将视图层对象的目录项转换为高层目录中对应的目录项，并将其和它的控制权转交给VFS；</p>
<p><strong>场景3.</strong> 文件和目录是非首次写入，则一定存在于高层目录：解决方案与场景2完全相同。</p>
<h4 id="3-文件创建操作"><a href="#3-文件创建操作" class="headerlink" title="3) 文件创建操作"></a>3) 文件创建操作</h4><p><strong>场景1.</strong> 创建在底层目录和高层目录中都不存在的文件或目录：直接在高层目录中创建新的文件或目录；</p>
<p><strong>场景2.</strong> 创建在底层目录已经存在，且在高层目录有whiteout文件的同名文件：Overlay文件系统会删除高层目录中的whiteout文件，并用新创建的文件替换它。通过这种方式，用户就能在统一合并视图层中看到高层目录中创建的新文件；</p>
<p><strong>场景3.</strong> 创建在底层目录已经存在，且在高层目录有whiteout文件的同名目录：由于同名目录上下层合并，所以若这时仅仅在高层目录中新建一个目录，则底层目录中对应目录中的内容也会暴露。因此，Overlay文件系统引入opaque属性，在读取上下层同名目录的目录项时，对高层目录中具有opaque属性的目录，Overlay文件系统会忽略在底层目录中同名目录下的所有目录项，以保证在用户视图中该新建目录仅是一个空目录。</p>
<h4 id="4-文件删除操作"><a href="#4-文件删除操作" class="headerlink" title="4) 文件删除操作"></a>4) 文件删除操作</h4><p><strong>场景1.</strong> 删除的文件或目录来自高层目录，且在底层目录中没有同名对象：由于高层目录中的对象是可读可写的，因此所有的文件操作都可以直接作用在高层目录。因此，Overlay文件系统会直接删除高层目录中对应的文件或目录；</p>
<p><strong>创建2.</strong> 删除的文件或目录来自底层目录，且在高层目录不存在覆盖文件：由于底层对象是只读的，因此Overlay文件系统不能直接删除底层目录中的文件或目录。Overlay文件系统必须既让用户认为目标已删除，却又不执行真正的删除操作；<br>为了达到这种效果，Overlay文件系统会在高层目录中删除文件的同时，创建同名的whiteout文件，用于屏蔽底层目录中的文件或目录。因此，当用户在视图层查看文件或目录时，由于whiteout文件的存在，底层目录中对应的文件或目录对用户不可见，就像被删除一样。但实际对象依旧存在于底层目录中；</p>
<p><strong>场景3.</strong> 删除的文件是高层目录的文件覆盖底层目录的文件，或删除的目录是上下层合并的目录：该场景的属于场景1和场景2的合并，Overlay文件系统既要删除高层目录中的文件和目录，也会在高层目录中创建同名的whiteout文件，从而保证高层目录的文件或目录被删除后而不至于底层对象被暴露出来。</p>
<h2 id="原子性保证"><a href="#原子性保证" class="headerlink" title="原子性保证"></a>原子性保证</h2><p>文件系统的原子性指所有的文件操作要么全部完成，要么全部不完成，不可能停滞在中间某个环节，否则有可能会破坏文件数据或元数据的原子性。而Overlay文件系统必须要保证文件创建、文件删除和写时复制等过程的原子性：</p>
<p><strong>场景1.</strong> 删除高层目录中的文件并创建whiteout文件：Overlay文件系统要保证高层目录中的删除目标文件和创建whiteout文件两个操作同时发生的原子性，不存在删除文件后whiteout文件还未创建的状态；</p>
<p><strong>场景2.</strong> 删除上下层合并目录：Overlay文件系统必须要保证被删除的目录为空，即目录和文件同时被删除的原子性，不存在部分数据删除，部分数据保留的状态；</p>
<p><strong>场景3.</strong> 新创建与whiteout同名的文件和目录：Overlay文件系统要保证删除whiteout文件和创建新文件两个操作同时发生的原子性，不存在删除whiteout文件后新文件还未创建的状态；</p>
<p><strong>场景4.</strong> 底层文件的写时复制：Overlay文件系统要保证文件拷贝的原子性，不存在只拷贝部分数据的状态。</p>
<img src="/images/fs/overlayatom.png" alt="overlayatom" style="zoom:67%;" />

<p>为了保证自身文件操作的原子性，Overlay文件系统使用工作目录(workdir)和重命名操作(rename)。如上图所示，以删除同时存在于高 / 底层目录的文件为例，其原子性保证的工作原理主要分为三个步骤：</p>
<p><strong>①创建：</strong>在工作目录中创建用于同名whiteout文件(若是写时复制过程，则将目标文件从底层目录复制到工作目录)；</p>
<p><strong>②交换：</strong>使用重命名操作将被删除的目标文件与工作目录中的whiteout文件进行交换 (若是写诗赋值过程，则通过重命名操作移动拷贝文件)来实现文件的原子性替换，而其原子性由宿主机文件系统已定义的重命名操作来保证；</p>
<p><strong>③删除：</strong>将工作目录中的目标文件删除(若是写时复制，则没有这个步骤)。</p>
<p>在上述的每个步骤中，即使系统出现异常或崩溃，磁盘也只会在工作目录中多出未被及时删除的目标文件、whiteout文件或拷贝不完全的文件；当操作系统恢复正常且再次挂载Overlay文件系统时，工作目录中的文件会被继续清除。通过这种方式，Overlay文件系统能够保证文件系统中所有基本文件操作的原子性。</p>
]]></content>
      <categories>
        <category>File System</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Overlay</tag>
      </tags>
  </entry>
  <entry>
    <title>Parameters of Camera</title>
    <url>/2020/Parameters-of-Camera/</url>
    <content><![CDATA[<h4 id="Step-1-设置存储格式和白平衡"><a href="#Step-1-设置存储格式和白平衡" class="headerlink" title="Step 1. 设置存储格式和白平衡"></a>Step 1. 设置存储格式和白平衡</h4><ul>
<li><p><strong>存储格式</strong></p>
<ul>
<li>RAW格式: 未经任何处理和压缩的无损照片格式</li>
<li>JPEG格式: 经过相机优化处理、被压缩的有损照片格式</li>
</ul>
</li>
<li><p><strong>色温</strong></p>
<ul>
<li>纯黑体在该温度下所发射的光颜色与某个光源所发射的光颜色看起来相同<ul>
<li>3000K⬇️            带红的白色，热烈温暖</li>
<li>3000K~5000K        白色，清爽</li>
<li>5000K⬆️            带蓝的白色，冰冷清凉</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>白平衡</strong></p>
<ul>
<li>数码相机对拍摄环境中由于光线色温不同而造成的偏色进行纠正<ul>
<li>自动        3500K~8000K</li>
<li>晴天        5200K</li>
<li>阴天        6000K</li>
<li>背阴        8000K</li>
<li>白炽灯        3000K</li>
<li>荧光灯        2700K~7200K</li>
<li>闪光灯        5400K</li>
<li>手动预设    混合光照环境</li>
<li>选择色温    2500K~10000K</li>
</ul>
</li>
<li>RAW模式不用担心白平衡设置错误</li>
<li>JPEG模式选择自动白平衡更保险</li>
</ul>
</li>
</ul>
<h4 id="Step-2-选择曝光模式"><a href="#Step-2-选择曝光模式" class="headerlink" title="Step 2. 选择曝光模式"></a>Step 2. 选择曝光模式</h4><ul>
<li><p><strong>光圈</strong></p>
<ul>
<li>光圈的F值 = 镜头的焦距 / 镜头光圈的直径<ul>
<li>相邻两档光圈的曝光量是两倍的关系<ul>
<li>F2.8光圈的曝光量是F4曝光量的两倍</li>
</ul>
</li>
</ul>
</li>
<li>相同条件下，<ul>
<li>光圈越大，曝光量越大，照片越明亮</li>
<li>光圈越小，曝光量越小，照片越暗淡</li>
</ul>
</li>
<li>在焦距、物距和背景距离不变的情况下，<ul>
<li>光圈越大，景深越小，背景虚化效果越强</li>
<li>光圈越小，景深越大，背景虚化效果越弱</li>
</ul>
</li>
<li>在光圈、物距和背景距离不变的情况下，<ul>
<li>焦距越长，景深越小，背景虚化效果越强</li>
<li>焦距越短，景深越大，背景虚化效果越弱</li>
</ul>
</li>
<li>在光圈、焦距和背景距离不变的情况下，<ul>
<li>物距越近，景深越小，背景虚化效果越强</li>
<li>物距越远，景深越大，背景虚化效果越弱</li>
</ul>
</li>
<li>在光圈、焦距和物距不变的情况下，<ul>
<li>背景距离拍摄主体越远，景深越小，背景虚化效果越强</li>
<li>背景距离拍摄主体越近，景深越大，背景虚化效果越弱</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>快门速度</strong></p>
<ul>
<li>快门是控制光线进入相机时间长短的装置</li>
<li>相同两档快门速度的曝光量之间是两倍的关系<ul>
<li>1/4s快门速度的曝光量是1/8快门速度的曝光量的两倍</li>
</ul>
</li>
<li>在光圈和感光度相同时，<ul>
<li>快门速度越慢，曝光量越大，照片越明亮</li>
<li>快门速度越快，曝光量越小，照片越暗淡</li>
</ul>
</li>
<li>安全快门<ul>
<li>手持拍摄时，保证拍摄到的照片不发虚所需要设置的最低快门速度</li>
<li>安全快门速度 = 焦距的倒数</li>
<li>尼康APS-C半画幅相机</li>
<li>安全快门速度 = 1 / (焦距 * 1.5)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>感光度</strong></p>
<ul>
<li>相邻两档感光度的曝光量之间是两倍的关系<ul>
<li>感光度200的曝光量是感光度100的曝光量的两倍</li>
</ul>
</li>
<li>相同条件下，<ul>
<li>感光度越高，曝光量越大，照片越明亮</li>
<li>感光度越低，曝光量越小，照片越暗淡</li>
</ul>
</li>
<li>ISO感光度不宜过高<ul>
<li>低感光度的照片噪点很少，画质细腻</li>
<li>高感光度的照片噪点较多，画质粗糙</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>曝光组合(明暗控制)</strong></p>
<ul>
<li>提亮照片<ul>
<li>开大光圈</li>
<li>降低快门速度</li>
<li>提高感光度</li>
</ul>
</li>
<li>压暗照片<ul>
<li>缩小光圈</li>
<li>提高快门速度</li>
<li>降低感光度</li>
</ul>
</li>
<li>相同的曝光效果<ul>
<li>感光度不变<ul>
<li>光圈增加一档，快门速度下降一档</li>
<li>光圈降低一档，快门速度增加一档</li>
</ul>
</li>
<li>光圈不变<ul>
<li>感光度增加一档，快门速度下降一档</li>
<li>感光度降低一档，快门速度增加一档</li>
</ul>
</li>
<li>快门速度不变<ul>
<li>感光度增加一档，光圈下降一档</li>
<li>感光度降低一档，光圈增加一档</li>
</ul>
</li>
</ul>
</li>
<li>曝光模式<ul>
<li>光圈优先A<ul>
<li>风光摄影: 小光圈减少虚化</li>
<li>人物摄影: 大光圈突出人物、虚化背景</li>
<li>弱光环境: 大光圈提高快门速度</li>
</ul>
</li>
<li>快门优先S<ul>
<li>高速快门: 凝固物体运动的瞬间</li>
<li>慢速快门: 记录物体的运动轨迹</li>
</ul>
</li>
<li>手动模式M<ul>
<li>光线稳定</li>
<li>弱光环境</li>
<li>闪光灯环境</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Step-3-设置曝光组合"><a href="#Step-3-设置曝光组合" class="headerlink" title="Step 3. 设置曝光组合"></a>Step 3. 设置曝光组合</h4><ul>
<li>室外晴天时的曝光组合设置<ul>
<li>小光圈 + 低感光度<ul>
<li>保证细腻画质和较大的景深效果</li>
</ul>
</li>
<li>大光圈 + 低感光度<ul>
<li>保证细腻画质和景深虚化的小景深效果</li>
</ul>
</li>
</ul>
</li>
<li>室外阴天或傍晚时的曝光组合设置<ul>
<li>大光圈 + 高感光度 <ul>
<li>保证快门速度高于安全快门</li>
</ul>
</li>
</ul>
</li>
<li>室内弱光环境的曝光组合设置<ul>
<li>大光圈 + 高感光度<ul>
<li>保证不拍虚的快门速度</li>
</ul>
</li>
</ul>
</li>
<li>室内窗户光的曝光组合模式<ul>
<li>大 / 中 / 小光圈 + 低 / 高感光度<ul>
<li>保证不拍虚的快门速度</li>
</ul>
</li>
</ul>
</li>
<li>应对多数场景的曝光组合设置<ul>
<li>小光圈 + 低感光度<ul>
<li>更大的景深效果和更细腻的画质</li>
</ul>
</li>
</ul>
</li>
<li>例外场景的曝光组合设置<ul>
<li>弱光环境: 小光圈 + 高感光度</li>
<li>星空题材: 大光圈 + 高感光度</li>
</ul>
</li>
<li>凝固物体运动瞬间的曝光组合设置<ul>
<li>浪花: 1/500s</li>
<li>动物: 1/2000s</li>
</ul>
</li>
<li>表现物体运动轨迹的曝光组合设置<ul>
<li>絮状流水: 1/2s</li>
<li>飞桥: 1/320s</li>
<li>飞驰的汽车: 1/60 ~ 1/30s</li>
<li>烟花: 小光圈 + 低感光度 + 5 ~ 20s</li>
</ul>
</li>
</ul>
<h4 id="Step-4-选择测光模式"><a href="#Step-4-选择测光模式" class="headerlink" title="Step 4. 选择测光模式"></a>Step 4. 选择测光模式</h4><ul>
<li>区域平均测光<ul>
<li>着重于焦点所对应的区域进行测光，同时对其他区域进行大体平均测光的智能测光模式</li>
</ul>
</li>
<li>中央重点测光<ul>
<li>着重于中央区域进行测光的测光模式</li>
</ul>
</li>
<li>点测光<ul>
<li>对取景范围中很小的一部分特定区域测光，而不管其他区域的测光模式</li>
</ul>
</li>
<li>测光步骤<ul>
<li>根据不同的场景选择不同的测光模式</li>
<li>选择测光点的位置</li>
<li>曝光锁定</li>
</ul>
</li>
</ul>
<h4 id="Step-5-选择对焦模式"><a href="#Step-5-选择对焦模式" class="headerlink" title="Step 5. 选择对焦模式"></a>Step 5. 选择对焦模式</h4><ul>
<li><strong>自动对焦</strong><ul>
<li>单次自动对焦模式(AF-S)<ul>
<li>每半按一次快门就会锁定对焦</li>
<li>拍摄静止物体(风景、人像、静物、花卉)</li>
</ul>
</li>
<li>连续自动对焦模式(AF-C)<ul>
<li>半按快门期间，若被摄体移动，相机会再次对焦</li>
<li>拍摄有连续运动轨迹的物体(赛车、运动员、走秀、飞鸟)</li>
</ul>
</li>
<li>与单点自动对焦组合<ul>
<li>只选定单一的对焦点对被摄体对焦</li>
</ul>
</li>
<li>与区域自动对焦组合<ul>
<li>选定单一的对焦区域对被摄体对焦</li>
</ul>
</li>
<li>自动切换对焦模式(AF-I)<ul>
<li>根据被摄体是否移动来选择 AF-S / AF-C</li>
<li>拍摄运动轨迹不规律的主题(足球、篮球、运动员)</li>
</ul>
</li>
<li>埋伏对焦<ul>
<li>先半按快门对焦，待运动物体经过该位置，按下快门完成拍摄</li>
<li>拍摄可预测运动物体的运动轨迹</li>
</ul>
</li>
</ul>
</li>
<li><strong>手动对焦</strong><ul>
<li>在对比度不够的场合</li>
<li>在弱光环境下</li>
<li>微距(景深范围浅)</li>
<li>隔着玻璃拍摄<ul>
<li>焦点锁定在玻璃上的污迹或倒影上</li>
</ul>
</li>
<li><strong>操作要领</strong><ul>
<li>在对焦时，在焦点附近来回拧动对焦环，缩小范围，然后确定焦点</li>
<li>使用三脚架时，可以打开实时取景，放大焦点，在用对焦环进行微调</li>
</ul>
</li>
</ul>
</li>
<li><strong>常见拍摄题材的对焦点选择</strong><ul>
<li>人像照片的对焦点选择<ul>
<li>人物面部: 前眼</li>
<li>人物半身、全身的肖像以及环境人像: 头部            风光照片的对焦点选择</li>
<li>无突出点: 对无穷远处对焦</li>
<li>有突出点: 对突出点对焦</li>
<li>最大限度的前后景深范围: 超焦距<ul>
<li>H = F^2 / (f * c) + F</li>
<li>H: 超焦距</li>
<li>F: 镜头焦距</li>
<li>f: 光圈值</li>
<li>c: 弥散圆直径<ul>
<li>全画幅相机的弥散圆直径: 0.032</li>
<li>半画幅相机的弥散圆直径: 0.019</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>合照照片的对焦点选择<ul>
<li>寻找关键人物作为焦点并进行追踪对焦，等待其余人达到和谐点时拍摄</li>
</ul>
</li>
<li>动物类照片的对焦点选择<ul>
<li>眼睛</li>
</ul>
</li>
<li>花卉照片的对焦点选择<ul>
<li>远距离: 花瓣</li>
<li>近距离: 花蕊</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    </p>
<h4 id="Step-6-设置曝光补偿，纠正曝光效果"><a href="#Step-6-设置曝光补偿，纠正曝光效果" class="headerlink" title="Step 6. 设置曝光补偿，纠正曝光效果"></a>Step 6. 设置曝光补偿，纠正曝光效果</h4><ul>
<li>曝光: 照片成像的明暗效果<ul>
<li>曝光不足: 欠曝</li>
<li>曝光过度: 过曝</li>
<li>准确的曝光: 整体亮度适中，明暗都有细节，色彩饱和、正常</li>
</ul>
</li>
<li><strong>查看曝光效果的方法</strong><ul>
<li>调整液晶屏亮度</li>
<li>设置高光预警</li>
<li>查看直方图<ul>
<li>左右两侧“不起墙”<ul>
<li>左侧起墙: 阴影区域欠曝</li>
<li>右侧起墙: 高光区域过曝</li>
<li>左右侧都无墙: 对比度低，照片发灰</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>曝光补偿</strong><ul>
<li>人为地改变光圈大小和快门速度，使照片更明亮或更暗<ul>
<li>光圈优先<ul>
<li>减少曝光补偿: 提高快门速度</li>
<li>增加曝光补偿: 降低快门速度</li>
</ul>
</li>
<li>快门优先<ul>
<li>减少曝光补偿: 减小光圈大小</li>
<li>增加曝光补偿: 增加光圈大小</li>
</ul>
</li>
</ul>
</li>
<li>提前设置曝光补偿<ul>
<li>白加黑减<ul>
<li>当画面中白色物体或亮部占比较多时，需要在自动曝光的基础上增加曝光<ul>
<li>雪地、大雾、大面积白色墙壁、人物的脸部</li>
</ul>
</li>
<li>当画面中黑色物体或暗部占比较多时，需要在自动曝光的基础上减少曝光<ul>
<li>日出日落、剪影效果</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title>Photography Skills</title>
    <url>/2020/Photography-Skills/</url>
    <content><![CDATA[<h4 id="Q1-如何拍近距离照片？"><a href="#Q1-如何拍近距离照片？" class="headerlink" title="Q1: 如何拍近距离照片？"></a>Q1: 如何拍近距离照片？</h4><p>AV档 + 最大光圈 + ISO自动 + 单点对焦</p>
<p>注：最近对焦距离 和 闪光灯开关</p>
<h4 id="Q2-如何抓拍运动物体？"><a href="#Q2-如何抓拍运动物体？" class="headerlink" title="Q2: 如何抓拍运动物体？"></a>Q2: 如何抓拍运动物体？</h4><p>TV档 / 调高快门速度 + AUTO自动感光度(ISO) + 自动对焦 + 高速连拍</p>
<h4 id="Q3-如何拍花卉？"><a href="#Q3-如何拍花卉？" class="headerlink" title="Q3: 如何拍花卉？"></a>Q3: 如何拍花卉？</h4><p>大光圈镜头 / 长焦镜头 (虚化好)</p>
<p>广角俯拍大场景</p>
<p>远距离低角度拍 Q1</p>
<p>特写 + 人工露珠 Q1</p>
<p>逆光低角度仰拍脉络：点测光对准比较亮的花瓣</p>
<p>正上方俯拍：花蕊 + 花瓣</p>
<h4 id="Q4-如何拍创意光绘？"><a href="#Q4-如何拍创意光绘？" class="headerlink" title="Q4: 如何拍创意光绘？"></a>Q4: 如何拍创意光绘？</h4><p>画面左右反向</p>
<p>手电筒 + 小皮筋 + 彩布 = 彩光手电筒</p>
<p>TV档(长快门时间) + 最低ISO + 手电筒对相机镜头</p>
<h4 id="Q5-汽车尾灯拉丝"><a href="#Q5-汽车尾灯拉丝" class="headerlink" title="Q5: 汽车尾灯拉丝"></a>Q5: 汽车尾灯拉丝</h4><p>选择车流较多，地势较高的天桥或街道</p>
<p>三脚架 + Tv档 + 5-20s快门 + ISO为100</p>
<p><strong>Reference</strong></p>
<p>​    <a href="https://www.bilibili.com/video/av26545377?p=1">https://www.bilibili.com/video/av26545377?p=1</a></p>
]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title>Sorting Algorithms</title>
    <url>/2021/Sorting-Algorithms/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul>
<li>概念: 从头到尾逐个处理数据，将当前数据和它前面的序列进行比较：若当前数据小于前一个数据，则交换位置；否则移动数组，处理下一个数据</li>
<li>特征: 稳定</li>
<li>性能: O(n) / O(n^2) / O(n^2)</li>
<li>代码: </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insSort</span><span class="params">(type Arr[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &gt;= <span class="number">1</span> &amp;&amp; Arr[j] &lt; Arr[j<span class="number">-1</span>]; j--)</span><br><span class="line">            swap(Arr, j<span class="number">-1</span>, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>概念: 从头到尾逐个处理数据，每次将当前数据和它后面的序列进行比较：若当前数据大于后一个数据，则交换位置，并后移下标；否则仅后移下标</li>
<li>特征: 稳定</li>
<li>性能: O(n^2) / O(n^2) / O(n^2)</li>
<li>代码:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubSort</span><span class="params">(type Arr[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = size<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">            <span class="keyword">if</span>(Arr[j] &lt; Arr[j<span class="number">-1</span>])</span><br><span class="line">                swap(Arr, j<span class="number">-1</span>, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul>
<li>概念: 第i次选择数组中第i小的数值，插入到第i个位置</li>
<li>特征: 不稳定</li>
<li>性能: O(n^2) / O(n^2) / O(n^2)</li>
<li>代码: </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selSort</span><span class="params">(type Arr[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> lowIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; size; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Arr[lowIndex] &gt; Arr[j])</span><br><span class="line">                lowIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(Arr, i, lowIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="shell排序"><a href="#shell排序" class="headerlink" title="shell排序"></a>shell排序</h2><ul>
<li><p>概念: 用 Gap 将数组等分划分，对较小的划分数组进行插入排序，再将较小的划分数组合并为较大的数据，并进行插入排序，直到得到完整的有序数组</p>
<p><img src="/images/bt/sort-1.png"></p>
</li>
<li><p>特征: 不稳定</p>
</li>
<li><p>性能 (Gap = 2): O(n) / O(n^2) / O(n^1.5)</p>
</li>
<li><p>代码:</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(type Arr[], <span class="keyword">int</span> size, <span class="keyword">int</span> gap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> inc = size/gap; inc &gt; <span class="number">0</span>; inc/=gap)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inc; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; size-inc; j+=inc)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j+inc; k &gt;= inc &amp;&amp; Arr[k] &lt; Arr[k-inc]; k-=inc)</span><br><span class="line">                    swap(Arr, k-inc, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li>概念: 选择数组中的一个数字作为轴值，将比轴值小的数放在轴值左边，比轴值大的数放在轴值右边，并通过递归依次处理轴值左边和右边的序列</li>
<li>特征: 不稳定</li>
<li>性能: O(nlogn) / O(n^2) / O(nlogn)</li>
<li>代码:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(type Arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = left;</span><br><span class="line">    <span class="keyword">int</span> tmp_val = Arr[tmp];</span><br><span class="line">    left++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; Arr[left] &lt;= tmp_val)  left++;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; Arr[right] &gt;= tmp_val) right--;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)    <span class="keyword">break</span>;</span><br><span class="line">        swap(Arr, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(Arr, tmp, right);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(type Arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = partition(Arr, left, right);</span><br><span class="line">    quickSort(Arr, left, p<span class="number">-1</span>);</span><br><span class="line">    quickSort(Arr, p+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li>概念: 每次通过递归将数组划分为长度相同的子序列，并用临时数组来进行排序；接着将子序列合并为一个更大的数组并排序</li>
<li>特征: 稳定 / 使用等长度的临时数组 (也可以通过 reverse 来实现)</li>
<li>性能: O(nlogn) / O(nlogn) / O(nlogn)</li>
<li>代码:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortCore</span><span class="params">(type Arr[], type tmp[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    mergeSortCore(Arr, tmp, left, mid);</span><br><span class="line">    mergeSortCore(Arr, tmp, mid+<span class="number">1</span>, right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, cur = left;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Arr[i] &lt; Arr[j]) tmp[cur++] = Arr[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[cur++] = Arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[cur++] = Arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right)   tmp[cur++] = Arr[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(cur = left; cur &lt;= right; cur++)</span><br><span class="line">        Arr[cur] = tmp[cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(type Arr[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    type *tmp_arr = <span class="keyword">new</span> type[size];</span><br><span class="line">    mergeSortCore(Arr, tmp_arr, <span class="number">0</span>, size<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] tmp_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化: 不需要临时数组</li>
</ul>
<p><img src="/images/bt/sort-2.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(type Arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)  swap(Arr, i++, j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(type Arr[], <span class="keyword">int</span> leftLen, <span class="keyword">int</span> rightLen)</span></span>&#123;</span><br><span class="line">    reverse(Arr, leftLen);</span><br><span class="line">    reverse(Arr + leftLen, rightLen);</span><br><span class="line">    reverse(Arr, leftLen + rightLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortExchange</span><span class="params">(type Arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; Arr[i] &lt;= Arr[j])   i++;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= right &amp;&amp; Arr[j] &lt; Arr[i])   j++;</span><br><span class="line">        exchange(Arr + i, mid + <span class="number">1</span> - i, j - mid - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        i = i + j - mid;</span><br><span class="line">        mid = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortNoTmp</span><span class="params">(type Arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    mergeSortNoTmp(Arr, left, mid); <span class="comment">// [left, mid]</span></span><br><span class="line">    mergeSortNoTmp(Arr, mid + <span class="number">1</span>, right);    <span class="comment">// [mid+1, right]</span></span><br><span class="line">    mergeSortExchange(Arr, left, mid, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li><p>概念: 构建最大堆，每次将堆顶元素弹出，并用剩余元素继续构建最大堆，直到空堆</p>
<p><img src="/images/bt/sort-3.png"></p>
</li>
<li><p>特征: 不稳定</p>
</li>
<li><p>性能: O(nlogn)</p>
</li>
<li><p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushHeap</span><span class="params">(type Arr[], <span class="keyword">int</span> hole)</span></span>&#123;</span><br><span class="line">    type t = Arr[hole];</span><br><span class="line">    <span class="keyword">int</span> parent = (hole - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(hole &gt; <span class="number">0</span> &amp;&amp; Arr[parent] &lt; t)&#123;</span><br><span class="line">        Arr[hole] = Arr[parent];</span><br><span class="line">        hole = parent;</span><br><span class="line">        parent = (hole - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arr[hole] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popHeap</span><span class="params">(type Arr[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    type t = Arr[size<span class="number">-1</span>];</span><br><span class="line">    Arr[size<span class="number">-1</span>] = Arr[<span class="number">0</span>];</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hole = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">2</span> * (hole + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(child &lt; size)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Arr[child - <span class="number">1</span>] &gt; Arr[child])</span><br><span class="line">            child--;</span><br><span class="line">        Arr[hole] = Arr[child];</span><br><span class="line">        hole = child;</span><br><span class="line">        child = <span class="number">2</span> * (hole + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(child == size)&#123;</span><br><span class="line">        Arr[hole] = Arr[child - <span class="number">1</span>];</span><br><span class="line">        hole = child - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arr[hole] = t;</span><br><span class="line">    pushHeap(Arr, hole);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeHeap</span><span class="params">(type Arr[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        pushHeap(Arr, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeHeap2</span><span class="params">(type Arr[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parent = (size - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(parent &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> hole = parent;</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">2</span> * (hole + <span class="number">1</span>);</span><br><span class="line">        type t = Arr[hole];</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(child &lt; size)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Arr[child - <span class="number">1</span>] &gt; Arr[child])</span><br><span class="line">                child--;</span><br><span class="line">            Arr[hole] = Arr[child];</span><br><span class="line">            hole = child;</span><br><span class="line">            child = <span class="number">2</span> * (hole + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(child == size)&#123;</span><br><span class="line">            Arr[hole] = Arr[child - <span class="number">1</span>];</span><br><span class="line">            hole = child - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arr[hole] = t;</span><br><span class="line">        pushHeap(Arr, hole);</span><br><span class="line">        parent--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(type Arr[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    makeHeap(Arr, size);</span><br><span class="line">    <span class="comment">// makeHeap2(Arr, size);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = size; j&gt;<span class="number">1</span>; j--)</span><br><span class="line">        popHeap(Arr, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>代码下载地址：<a href="https://xiaoli777.github.io/codes/Sortings.cpp">https://xiaoli777.github.io/codes/Sortings.cpp</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>The Introduction to Kube-proxy</title>
    <url>/2021/The-Introduction-to-Kube-proxy/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Kube-proxy是Kubernetes的核心组件，部署在每个节点上。作为服务的透明代理兼负载均衡器（在K8s中，提供相同服务的一组Pod可以抽象成一个服务，通过统一入口对外提供服务，每个服务都有一个虚拟IP地址和端口号供客户端访问），其核心功能是将到某个服务的访问请求转发到后端的Pod实例上。</p>
<p>Kube-proxy维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与Pod进行网络通信。如果操作系统提供了数据包过滤层，Kube-proxy会通过它来实现网络规则。否则，Kube-proxy仅转发流量本身。</p>
<p>此外，服务的虚拟IP与NodePort等概念是kube-proxy通过iptables的NAT转换实现的，Kube-proxy在运行过程中动态创建与服务相关的iptables规则，这些规则实现了将访问服务请求负载分发到后端Pod的功能。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Kube-proxy提供集群内部的服务发现和负载均衡，在每个节点上，Kubernetes都通过DeamonSet的方式部署一个Kube-proxy。这一设计体现了Kube-proxy的伸缩性：需求访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多。</p>
<p>如图所示，Kube-proxy从API Server获取所有的服务信息，并根据服务信息创建代理服务，实现从服务到Pod的请求路由和转发，以及虚拟转发网络。</p>
<img src="/images/kube/kube-7.png" alt="img" style="zoom:80%;" />

<p>Kube-proxy使用DaemonSet进行部署：DaemonSet管理K8s集群中每个node上仅运行一份Pod的副本实例。当node加入集群时创建Pod，当node离开集群时回收Pod。如果删除DaemonSet，其创建的所有Pod也被删除，DaemonSet中的Pod将覆盖整个集群。</p>
<h2 id="功能性"><a href="#功能性" class="headerlink" title="功能性"></a>功能性</h2><table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">子功能</th>
<th align="center">Kube-proxy</th>
</tr>
</thead>
<tbody><tr>
<td align="center">服务发现</td>
<td align="center"></td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center">流量治理</td>
<td align="center">HTTP</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">TCP</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">UDP</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">SCTP</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center">负载均衡</td>
<td align="center">随机</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">轮询</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center">外部访问</td>
<td align="center"></td>
<td align="center"><code>✓</code></td>
</tr>
</tbody></table>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><h3 id="Userspace模式"><a href="#Userspace模式" class="headerlink" title="Userspace模式"></a>Userspace模式</h3><p>在用户空间模式下，kube-proxy进程是一个TCP/UDP代理，负责从Service到Pod的访问流量的转发。当某个Pod以Cluster IP方式访问某个Service的时候，这个流量会被Pod所在本机的iptables转发到本机的kube-proxy进程，然后由kube-proxy建立起到后端Pod的TCP/UDP链接，随后将请求转发到某个后端的Pod上，并在这个过程中实现负载均衡功能。</p>
<img src="/images/kube/kube-8.png" alt="img" style="zoom:50%;" />

<p>kube-proxy 会为每个 Service 随机监听一个端口，并增加一条 IPtables 规则。从客户端到 ClusterIP:Port 的报文都会被重定向到该端口，而端口收到报文后，通过负载均衡策略分发给对应的 Pod。</p>
<p>用户空间模式的问题在于，Service的请求会先从用户空间进入内核iptables，然后再回到用户空间，由kube-proxy完成后端Endpoints的选择和代理工作，这样流量从用户空间进出内核带来的性能损耗是不可接受的。</p>
<h3 id="Iptables模式"><a href="#Iptables模式" class="headerlink" title="Iptables模式"></a>Iptables模式</h3><p>Iptable模式下的kube-proxy不再起到Proxy的作用，其核心功能：通过API Server的Watch接口实时追踪跟踪Service与Endpoint的变更信息，并更新对应的iptables规则，Client的请求流量则通过iptables的NAT机制“直接路由”到目标Pod。</p>
<img src="/images/kube/kube-9.png" alt="img" style="zoom:50%;" />

<p>Iptable模式是全自动模式：根据Kubernetes的网络模型，一个Node上的Pod与其他Node上的Pod应该能够直接建立双向的TCP/IP通信通道，所以如果直接修改iptables规则，则也可以实现kube-proxy的功能。并且，iptables模式完全工作在内核态，不再经过用户态的kube-proxy中转，因此性能更强。</p>
<p>Iptable模式的缺陷在于：在集群中的Service和Pod大量增加以后，iptables中的规则会急速膨胀，导致性能显著下降，在某些极端情况下甚至会出现规则丢失的情况，并且这种故障难以重现与排查。</p>
<h3 id="IPVS模式"><a href="#IPVS模式" class="headerlink" title="IPVS模式"></a>IPVS模式</h3><p>Iptables是为防火墙而设计的；IPVS（IP Virtual Server）则专门用于高性能负载均衡，并使用更高效的数据结构（Hash表），允许几乎无限的规模扩张。相比iptables，IPVS拥有一下明显优势：</p>
<p>· 为大型集群提供了更好的可扩展性和性能</p>
<p>· 支持比iptables更复杂的负载均衡算法（最小负载、最少连接、加权等）</p>
<p>· 支持服务器健康检查和连接重试等功能</p>
<p>· 可动态修改ipset的集合</p>
<img src="/images/kube/kube-10.png" alt="img" style="zoom:50%;" />

<p>Ipset是iptables的一种扩展，引入了带索引的数据结构。因此，当规则很多时，ipset可提供高效地查找和匹配。</p>
]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>ServiceMesh</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>The Overview of EdgeMesh</title>
    <url>/2021/The-Overview-of-EdgeMesh/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>EdgeMesh is a part of KubeEdge, and provides a simple network solution for the inter-communications between services at edge scenarios.</p>
<h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h4><p>KubeEdge is build based on Kubernetes, extending cloud-native containerized application orchestration capabilities to the edge. However, at the scenario of edge computer, the network topology is more complex. Edge nodes in different areas are offen not interconnected, and the inter-communication of traffic between applications is the primary requirement of the business. For this scenairo, EdgeMesh offers a solution.</p>
<h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><p>As the component of data panel on a KubeEdge cluster, EdgeMesh offers sample capacities (e.g, service discovery, traffic proxy, etc.) for applications running on the KubeEdge cluster, thus shielding the complex network topology at the edge scenairo.</p>
<h4 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h4><p>EdgeMesh satisfies the new requirements in edge scenarios (e.g., limited edge resources, unstable edge cloud network, etc.), that is, high availability, high reliability, and extreme lightweight:</p>
<ul>
<li><strong>High availability</strong><ul>
<li>Open up the network between edge nodes by using the edge cloud channel in KubeEdge</li>
<li>Divide the communication between edge nodes into intra-LAN and cross-LAN<ul>
<li>Intra-LAN communication: direct access</li>
<li>Cross-LAN communication: forwarding through the cloud</li>
</ul>
</li>
</ul>
</li>
<li><strong>High reliability (offline scenario)</strong><ul>
<li>Both control plane and data plane traffic are delivered through the edge cloud channel</li>
<li>EdgeMesh internally implements a lightweight DNS server, thus no longer accessing the cloud DNS</li>
</ul>
</li>
<li><strong>Extreme lightweight</strong><ul>
<li>Each node has one and only one EdgeMesh, which saves edge resources</li>
</ul>
</li>
</ul>
<h5 id="User-value"><a href="#User-value" class="headerlink" title="User value"></a>User value</h5><ul>
<li>For edge devices with limited resources, EdgeMesh provides a lightweight and highly integrated software with service discovery</li>
<li>In the scene of Field Edge, compared to the mechanism of coredns + kube-proxy + cni service discovery , users only need to simply deploy an EdgeMesh to finish their goals</li>
</ul>
<h4 id="Key-Features"><a href="#Key-Features" class="headerlink" title="Key Features"></a>Key Features</h4><table align="center">
    <tr>
        <th align="center">Feature</th>
        <th align="center">Sub-Feature</th>
        <th align="center">Realization Degree</th>  
    </tr >
    <tr >
        <td align="center">Service Discovery</td>
        <td align="center">/</td>
        <td align="center">✓</td>
    </tr>
    <tr>
        <td rowspan="4" align="center">Traffic Governance</td>
         <td align="center">HTTP</td>
        <td align="center">✓</td>
    </tr>
    <tr>
         <td align="center">TCP</td>
        <td align="center">✓</td>
    </tr>
    <tr>
         <td align="center">Websocket</td>
        <td align="center">✓</td>
    </tr>
    <tr>
         <td align="center">HTTPS</td>
        <td align="center">✓</td>
    </tr>
    <tr>
        <td rowspan="3" align="center">Load Balance</td>
         <td align="center">Random</td>
        <td align="center">✓</td>
    </tr>
    <tr>
         <td align="center">Round Robin</td>
        <td align="center">✓</td>
    </tr>
    <tr>
        <td align="center">Session Persistence</td>
        <td align="center">✓</td>
    </tr>
    <tr>
        <td align="center">External Access</td>
        <td align="center">/</td>
        <td align="center">✓</td>
    </tr>
    <tr>
        <td align="center">Multi-NIC Monitoring</td>
        <td align="center">/</td>
        <td align="center">✓</td>
    </tr>
  <tr>
        <td rowspan="2" align="center">Cross-Subnet Communication</td>
         <td align="center">Cross-Cloud Communication</td>
        <td align="center">+</td>
    </tr>
    <tr>
         <td align="center">Cross-LAN E2E Communication</td>
        <td align="center">+</td>
    </tr>
  <tr>
        <td align="center">Edge CNI</td>
         <td align="center">Cross-Subnet Pod Communication</td>
        <td align="center">+</td>
    </tr>
</table>



<p><strong>Noting:</strong></p>
<ul>
<li><code>✓</code> Features supported by the EdgeMesh version </li>
<li><code>+</code> Features not available in the EdgeMesh version, but will be supported in subsequent versions</li>
<li><code>-</code> Features not available in the EdgeMesh version, or deprecated features</li>
</ul>
<h4 id="Future-Works"><a href="#Future-Works" class="headerlink" title="Future Works"></a>Future Works</h4><img src="/images/kube/em-intro.png" style="zoom:80%;" />

<p>At present, the implementation of EdgeMesh relies on the connectivity of the host network. In the future, EdgeMesh will realize the capabilities of CNI plug-ins, and realize the Pod network connectivity between edge nodes and nodes on the cloud, or edge nodes across LANs in a  compatible manner with mainstream CNI plug-ins (e.g., flannel / calico, etc). Finally, EdgeMesh can even replace part of its own components with cloud-native components (e.g., replacing <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> to achieve the capabilities of the Cluster IP, replacing <a href="https://kubernetes.io/docs/tasks/administer-cluster/nodelocaldns/">node local dns cache </a> to achieve node-level dns capabilities, and replace <a href="https://www.envoyproxy.io/">envoy</a> to achieve mesh-layer capabilities).</p>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><img src="/images/kube/em-arch.png" style="zoom:67%;" />

<p>To ensure the capability of service discovery in some edge devices with low-version kernels or low-version iptables, EdgeMesh adopts the userspace mode in its implementation of the traffic proxy. In addition, it also comes with a lightweight DNS resolver. As shown in the figure above, the core components of EdgeMesh include:</p>
<ul>
<li><strong>Proxier</strong>: Responsible for configuring the kernel’s iptables rules, and intercepting requests to the EdgeMesh process</li>
<li><strong>DNS</strong>: Built-in DNS resolver, which resolves the DNS request in the node into a service cluster IP</li>
<li><strong>Traffic</strong>: A traffic forwarding module based on the Go-chassis framework, which is responsible for forwarding traffic between applications</li>
<li><strong>Controller</strong>: Obtains metadata (e.g., Service, Endpoints, Pod, etc.) through the list-watch capability on the edge side of KubeEdge</li>
</ul>
<h4 id="How-It-Works"><a href="#How-It-Works" class="headerlink" title="How It Works"></a>How It Works</h4><ul>
<li>Through the capability of list-watch on the edge of KubeEdge, EdgeMesh monitors the addition, deletion and modification of metadata (e.g., Services and Endpoints), and then creates iptables rules based on Services and Endpoints</li>
<li>EdgeMesh uses the same ways (e.g., Cluster IP, domain name) as the K8s Service to access services</li>
<li>When client’s requests accessing a service reach a node with EdgeMesh, it will enter the kernel’s iptables at first</li>
<li>The iptables rules previously configured by EdgeMesh will redirect requests, and forward them all to the port 40001 which is occupied by the EdgeMesh process (data packets from kernel mode to user mode)</li>
<li>After requests enter the EdgeMesh process, the EdgeMesh process completes the selection of backend Pods (load balancing occurs here), and then sends requests to the host where the Pod is located</li>
</ul>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h4 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h4><p>Before using EdgeMesh, you need to understand the following prerequisites at first:</p>
<ul>
<li>when using edgemesh’s capabilities, the Pod is required a hostPort (as shown in following examples)</li>
<li>while using DestinationRule, the name of the DestinationRule must be equal to the name of the corresponding Service. Edgemesh will determine the DestinationRule in the same namespace according to the name of the Service</li>
<li>Service ports must be named. The key/value pairs of port name must have the following syntax: name: &lt;protocol&gt;[-&lt;suffix&gt;]</li>
</ul>
<h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><p>At the edge node, close EdgeMesh, open metaserver, and restart edgecore</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/kubeedge/config/edgecore.yaml</span></span><br><span class="line">modules:</span><br><span class="line">  ..</span><br><span class="line">  edgeMesh:</span><br><span class="line">    enable: false</span><br><span class="line">  metaManager:</span><br><span class="line">    metaServer:</span><br><span class="line">      enable: true</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl restart edgecore</span></span><br></pre></td></tr></table></figure>
<p>On the cloud, open the dynamic controller module, and restart cloudcore</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/kubeedge/config/cloudcore.yaml</span></span><br><span class="line">modules:</span><br><span class="line">  ..</span><br><span class="line">  dynamicController:</span><br><span class="line">    enable: true</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<p>At the edge node, check if list-watch works</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl 127.0.0.1:10550/api/v1/services</span></span><br><span class="line">&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;items&quot;:[&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:&#123;&quot;creationTimestamp&quot;:&quot;2021-04-14T06:30:05Z&quot;,&quot;labels&quot;:&#123;&quot;component&quot;:&quot;apiserver&quot;,&quot;provider&quot;:&quot;kubernetes&quot;&#125;,&quot;name&quot;:&quot;kubernetes&quot;,&quot;namespace&quot;:&quot;default&quot;,&quot;resourceVersion&quot;:&quot;147&quot;,&quot;selfLink&quot;:&quot;default/services/kubernetes&quot;,&quot;uid&quot;:&quot;55eeebea-08cf-4d1a-8b04-e85f8ae112a9&quot;&#125;,&quot;spec&quot;:&#123;&quot;clusterIP&quot;:&quot;10.96.0.1&quot;,&quot;ports&quot;:[&#123;&quot;name&quot;:&quot;https&quot;,&quot;port&quot;:443,&quot;protocol&quot;:&quot;TCP&quot;,&quot;targetPort&quot;:6443&#125;],&quot;sessionAffinity&quot;:&quot;None&quot;,&quot;type&quot;:&quot;ClusterIP&quot;&#125;,&quot;status&quot;:&#123;&quot;loadBalancer&quot;:&#123;&#125;&#125;&#125;,&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&quot;prometheus.io/port&quot;:&quot;9153&quot;,&quot;prometheus.io/scrape&quot;:&quot;true&quot;&#125;,&quot;creationTimestamp&quot;:&quot;2021-04-14T06:30:07Z&quot;,&quot;labels&quot;:&#123;&quot;k8s-app&quot;:&quot;kube-dns&quot;,&quot;kubernetes.io/cluster-service&quot;:&quot;true&quot;,&quot;kubernetes.io/name&quot;:&quot;KubeDNS&quot;&#125;,&quot;name&quot;:&quot;kube-dns&quot;,&quot;namespace&quot;:&quot;kube-system&quot;,&quot;resourceVersion&quot;:&quot;203&quot;,&quot;selfLink&quot;:&quot;kube-system/services/kube-dns&quot;,&quot;uid&quot;:&quot;c221ac20-cbfa-406b-812a-c44b9d82d6dc&quot;&#125;,&quot;spec&quot;:&#123;&quot;clusterIP&quot;:&quot;10.96.0.10&quot;,&quot;ports&quot;:[&#123;&quot;name&quot;:&quot;dns&quot;,&quot;port&quot;:53,&quot;protocol&quot;:&quot;UDP&quot;,&quot;targetPort&quot;:53&#125;,&#123;&quot;name&quot;:&quot;dns-tcp&quot;,&quot;port&quot;:53,&quot;protocol&quot;:&quot;TCP&quot;,&quot;targetPort&quot;:53&#125;,&#123;&quot;name&quot;:&quot;metrics&quot;,&quot;port&quot;:9153,&quot;protocol&quot;:&quot;TCP&quot;,&quot;targetPort&quot;:9153&#125;],&quot;selector&quot;:&#123;&quot;k8s-app&quot;:&quot;kube-dns&quot;&#125;,&quot;sessionAffinity&quot;:&quot;None&quot;,&quot;type&quot;:&quot;ClusterIP&quot;&#125;,&quot;status&quot;:&#123;&quot;loadBalancer&quot;:&#123;&#125;&#125;&#125;],&quot;kind&quot;:&quot;ServiceList&quot;,&quot;metadata&quot;:&#123;&quot;resourceVersion&quot;:&quot;377360&quot;,&quot;selfLink&quot;:&quot;/api/v1/services&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Build EdgeMesh image (not necessary)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t edgemesh:0.1 -f build/Dockerfile .</span></span><br></pre></td></tr></table></figure>
<p>Deploy EdgeMesh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Please <span class="built_in">set</span> the subNet to the value of service-cluster-ip-range of kube-apiserver.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can obtain the value from the /etc/kubernetes/manifests/kube-apiserver.yaml file on the master node</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f build/kubernetes/edgemesh/03-configmap.yaml</span></span><br><span class="line">configmap/edgemesh-cfg created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f build/kubernetes/edgemesh/04-daemonset.yaml</span></span><br><span class="line">daemonset.apps/edgemesh created</span><br></pre></td></tr></table></figure>


<h4 id="Test-Case"><a href="#Test-Case" class="headerlink" title="Test Case"></a>Test Case</h4><p><strong>HTTP</strong></p>
<p>At the edge node, deploy a HTTP container application, and relevant service</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f example/hostname.yaml</span></span><br></pre></td></tr></table></figure>
<p>Go to that edge node, use ‘curl’ to access the service, and print out the hostname of the container</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl hostname-lb-svc.edgemesh-test:12345</span></span><br></pre></td></tr></table></figure>


<p><strong>TCP</strong></p>
<p>At the edge node 1, deploy a TCP container application, and relevant service    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f example/tcp-echo-service.yaml</span></span><br></pre></td></tr></table></figure>
<p>At the edge node 1, use ‘telnet’ to access the service        </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> telnet tcp-echo-service.edgemesh-test 2701</span></span><br></pre></td></tr></table></figure>


<p><strong>Websocket</strong></p>
<p>At the edge node 1, deploy a websocket container application, and relevant service    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f example/websocket-pod-svc.yaml</span></span><br></pre></td></tr></table></figure>
<p>Enter the container, and use ./client to access the service</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it 2a6ae1a490ae bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./client --addr ws-svc.edgemesh-test:12348</span></span><br></pre></td></tr></table></figure>


<p><strong>Load Balance</strong></p>
<p>The capability of load balance needs to add the CRD ‘DestinationRule’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f build/istio/destinationrule-crd.yaml</span></span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/destinationrules.networking.istio.io created</span><br></pre></td></tr></table></figure>
<p>Use the ‘loadBalancer’ in ‘DestinationRule’ to select LB modes    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim example/hostname-lb-random.yaml</span></span><br><span class="line">spec</span><br><span class="line">..</span><br><span class="line">  trafficPolicy:</span><br><span class="line">    loadBalancer:</span><br><span class="line">      simple: RANDOM</span><br><span class="line">..    </span><br></pre></td></tr></table></figure>


<h2 id="EdgeMesh-Ingress-Gateway"><a href="#EdgeMesh-Ingress-Gateway" class="headerlink" title="EdgeMesh Ingress Gateway"></a>EdgeMesh Ingress Gateway</h2><p>EdgeMesh ingress gateway provides a ability to access services in external edge nodes.</p>
<p><img src="/images/fs/em-ig.png"></p>
<h4 id="HTTP-Gateway"><a href="#HTTP-Gateway" class="headerlink" title="HTTP Gateway"></a>HTTP Gateway</h4><p>Create two CRDs: ‘Gateway’ and ‘VirtualService’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f build/istio/gateway-crd.yaml</span></span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/gateways.networking.istio.io created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f build/istio/virtualservice-crd.yaml</span></span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/virtualservices.networking.istio.io created</span><br></pre></td></tr></table></figure>
<p>Deploy edgemesh-gateway</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f 03-configmap.yaml</span> </span><br><span class="line">configmap/edgemesh-gateway-cfg created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f 04-deployment.yaml</span> </span><br><span class="line">deployment.apps/edgemesh-gateway created</span><br></pre></td></tr></table></figure>
<p>Create ‘Gateway’ and ‘VirtualService’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f example/hostname-lb-random-gateway.yaml</span></span><br><span class="line">pod/hostname-lb-edge2 created</span><br><span class="line">pod/hostname-lb-edge3 created</span><br><span class="line">service/hostname-lb-svc created</span><br><span class="line">gateway.networking.istio.io/edgemesh-gateway configured</span><br><span class="line">destinationrule.networking.istio.io/hostname-lb-edge created</span><br><span class="line">virtualservice.networking.istio.io/edgemesh-gateway-svc created</span><br></pre></td></tr></table></figure>
<p>Check if the edgemesh-gateway is successfully deployed</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get gw -n edgemesh-test</span></span><br><span class="line">NAME               AGE</span><br><span class="line">edgemesh-gateway   3m30s</span><br></pre></td></tr></table></figure>
<p>Finally, use the IP and the port exposed by the VirtualService to access</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl 192.168.0.211:12345</span></span><br></pre></td></tr></table></figure>


<h4 id="HTTPS-GateWay"><a href="#HTTPS-GateWay" class="headerlink" title="HTTPS GateWay"></a>HTTPS GateWay</h4><p>Create a test key file</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj <span class="string">&quot;/CN=kubeedge.io&quot;</span></span><br><span class="line">Generating a RSA private key</span><br><span class="line">............+++++</span><br><span class="line">.......................................................................................+++++</span><br><span class="line">writing new private key to <span class="string">&#x27;tls.key&#x27;</span></span><br><span class="line">-----</span><br></pre></td></tr></table></figure>
<p>Create a ‘Secret’ according to the key file</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create secret tls gw-secret --key tls.key --cert tls.crt -n edgemesh-test</span><br><span class="line">secret/gw-secret created</span><br></pre></td></tr></table></figure>
<p>Create a Secret-bound ‘Gateway’ and routing rules ‘VirtualService’</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f example/hostname-lb-random-gateway-tls.yaml</span><br><span class="line">pod/hostname-lb-edge2 created</span><br><span class="line">pod/hostname-lb-edge3 created</span><br><span class="line">service/hostname-lb-svc created</span><br><span class="line">gateway.networking.istio.io/edgemesh-gateway configured</span><br><span class="line">destinationrule.networking.istio.io/hostname-lb-edge created</span><br><span class="line">virtualservice.networking.istio.io/edgemesh-gateway-svc created</span><br></pre></td></tr></table></figure>
<p>Finally, use the certificate for a HTTPS access</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -k --cert ./tls.crt --key ./tls.key https://192.168.0.129:12345</span><br></pre></td></tr></table></figure>


<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/xiaoli777/edgemesh">https://github.com/xiaoli777/edgemesh</a></p>
<p><a href="https://docs.kubeedge.io/en/docs/advanced/edgemesh/">https://docs.kubeedge.io/en/docs/advanced/edgemesh/</a></p>
<p><a href="https://www.bilibili.com/video/BV18i4y1N7SV">https://www.bilibili.com/video/BV18i4y1N7SV</a></p>
]]></content>
      <categories>
        <category>Edge Computing</category>
      </categories>
      <tags>
        <tag>KubeEdge</tag>
        <tag>ServiceMesh</tag>
      </tags>
  </entry>
  <entry>
    <title>This is xiaoli7</title>
    <url>/2020/This-is-xiaoli7/</url>
    <content><![CDATA[<h1 id="杨-晓礼"><a href="#杨-晓礼" class="headerlink" title="杨 晓礼"></a>杨 晓礼</h1><p><strong><code>互联网实习生</code></strong> &amp; <strong><code>教学助理</code></strong> &amp; <strong><code>研究生</code></strong></p>
<blockquote>
<ul>
<li>Github: <a href="https://github.com/xiaoli777">https://github.com/xiaoli777</a></li>
<li>电子邮箱: <a href="mailto:&#120;&#x69;&#97;&#111;&#108;&#105;&#x79;&#97;&#x6e;&#x67;&#49;&#57;&#x39;&#52;&#x40;&#111;&#x75;&#x74;&#108;&#x6f;&#x6f;&#x6b;&#x2e;&#99;&#x6f;&#x6d;">&#120;&#x69;&#97;&#111;&#108;&#105;&#x79;&#97;&#x6e;&#x67;&#49;&#57;&#x39;&#52;&#x40;&#111;&#x75;&#x74;&#108;&#x6f;&#x6f;&#x6b;&#x2e;&#99;&#x6f;&#x6d;</a></li>
<li>微信: jueqingzhan163</li>
</ul>
</blockquote>
<h2 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h2><h4 id="加利福尼亚大学戴维斯分校"><a href="#加利福尼亚大学戴维斯分校" class="headerlink" title="加利福尼亚大学戴维斯分校"></a>加利福尼亚大学戴维斯分校</h4><p><code>2020年9月 - 至今</code>, <code>萨克拉门托, 美国</code></p>
<ul>
<li><strong>计算机科学</strong> 在读研究生</li>
<li>GPA: <strong>3.7+/4.0</strong></li>
</ul>
<h4 id="华中科技大学"><a href="#华中科技大学" class="headerlink" title="华中科技大学"></a><strong>华中科技大学</strong></h4><p><code>2017年9月 - 2020年6月</code>, <code>武汉, 中国</code></p>
<ul>
<li><strong>计算机体系结构</strong> 工学硕士学位</li>
<li>GPA: <strong>82.65/100.00</strong></li>
</ul>
<h4 id="湖南大学"><a href="#湖南大学" class="headerlink" title="湖南大学"></a>湖南大学</h4><p><code>2013年9月 - 2017年6月</code>, <code>长沙, 中国</code></p>
<ul>
<li><strong>计算机体系结构</strong> 工学学士学位</li>
<li>GPA: <strong>3.62/4.50</strong></li>
</ul>
<h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h4 id="服务网格的对比与分析"><a href="#服务网格的对比与分析" class="headerlink" title="服务网格的对比与分析"></a><strong>服务网格的对比与分析</strong></h4><p><code>研究人员</code>, <code>2021年2月 - 至今</code>, <code>华为技术有限公司, 中国</code></p>
<ul>
<li>学习并调研3大服务网格 (Istio, Kube-proxy, EdgeMesh)</li>
<li>从架构、功能和性能的角度, 对比并分析这些服务网格</li>
<li>设计测试程序来评估这些服务网格的性能 (DOING)</li>
</ul>
<h4 id="跨边云服务发现与流量治理"><a href="#跨边云服务发现与流量治理" class="headerlink" title="跨边云服务发现与流量治理"></a>跨边云服务发现与流量治理</h4><p><code>开发人员</code>, <code>2021年1月 - 2021年2月</code>,  <code>华为技术有限公司, 中国</code></p>
<ul>
<li>学习边缘云平台的架构, 并调研其APIs</li>
<li>进行实验来验证该项目的可行性</li>
<li>通过RESTful APIs来实现自动化环境创建 (LoC: 500+)</li>
</ul>
<h4 id="EdgeMesh的性能测试"><a href="#EdgeMesh的性能测试" class="headerlink" title="EdgeMesh的性能测试"></a>EdgeMesh的性能测试</h4><p><code>测试人员</code>, <code>2020年11月 - 2020年12月</code>, <code>华为技术有限公司, 中国</code></p>
<ul>
<li>通过阅读代码和相关文献, 来学习EdgeMesh的设计和功能</li>
<li>设计测试程序, 来评估EdgeMesh的性能 (LoC: 100+)</li>
<li>根据测试结果, 输出一份综合性测试报告Outputted a comprehensive report to analyze the test results</li>
</ul>
<h4 id="容器文件系统扩展性的评估与优化"><a href="#容器文件系统扩展性的评估与优化" class="headerlink" title="容器文件系统扩展性的评估与优化"></a>容器文件系统扩展性的评估与优化</h4><p><code>研究人员</code>, <code>2018年6月 - 2020年6月</code>, <code>华中科技大学, 中国</code></p>
<ul>
<li>扩展FXMARK，来支持Overlay2的扩展性评估 (LoC: 1000+)</li>
<li>分析得出两大扩展性瓶颈：文件重定向和重命名锁竞争</li>
<li>提出可记忆重定向策略，将打开容器文件的性能提升约10%</li>
<li>设计并实现免锁重命名策略，将重命名、写时复制和删除文件的性能优化100%-300%</li>
</ul>
<h4 id="《云计算：信息社会的基础设施和服务引擎》"><a href="#《云计算：信息社会的基础设施和服务引擎》" class="headerlink" title="《云计算：信息社会的基础设施和服务引擎》"></a>《云计算：信息社会的基础设施和服务引擎》</h4><p><code>协助编者</code>, <code>2018年3月 - 2018年6月</code>, <code>华中科技大学, 中国</code></p>
<ul>
<li>寻找、整理并组织数百篇相关资料和文献(书籍、网上资料等)</li>
<li>全程协助写作，包括目录和章节内容(超过100,000字)</li>
</ul>
<h4 id="电力负荷预测可视化平台"><a href="#电力负荷预测可视化平台" class="headerlink" title="电力负荷预测可视化平台"></a>电力负荷预测可视化平台</h4><p><code>开发人员</code>, <code>2016年12月 - 2017年6月</code>, <code>湖南大学, 中国</code></p>
<ul>
<li>设计平台架构与数据库，可支持TB级别数据的存储与查询</li>
<li>实现基于SVM的预测算法，其平均准确率高达97%</li>
<li>设计并实现20种以上的数据可视化图表</li>
<li>提高跨平台的兼容性，和预测算法的扩展性</li>
</ul>
<h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><h4 id="边缘云创新实验室"><a href="#边缘云创新实验室" class="headerlink" title="边缘云创新实验室"></a>边缘云创新实验室</h4><p><code>开发工程师</code>, <code>2020年11月 - 至今</code>, <code>华为技术有限公司, 中国</code></p>
<ul>
<li>学习边缘运平台 (KubeEdge) 的架构</li>
<li>熟练地使用容器化技术 (Docker, Kubernetes, 服务网格等)</li>
<li>设计并进行有关EdgeMesh的性能测试</li>
<li>参与跨边云服务发现与流量治理的开发工作</li>
<li>对比并分析数个服务网格 (Istio, Kube-proxy, EdgeMesh)</li>
</ul>
<h4 id="工程学院"><a href="#工程学院" class="headerlink" title="工程学院"></a>工程学院</h4><p><code>教学助理</code>, <code>2021年1月 - 2021年3月</code>, <code>加州大学戴维斯分校，美国</code></p>
<ul>
<li>向200名学生提供ECS 150 (操作系统) 的Office Hours</li>
<li>引导学生完成3个课程项目 (shell, 线程库, 文件系统)</li>
<li>口语面试超过50个学生, 并给予有效的反馈</li>
<li>参与5个评分活动 (3个课程项目, 2次期中考试)</li>
</ul>
<h4 id="集群与网格计算实验室"><a href="#集群与网格计算实验室" class="headerlink" title="集群与网格计算实验室"></a>集群与网格计算实验室</h4><p><code>集群管理员</code>, <code>2019年3月 - 2020年6月</code>, <code>华中科技大学, 中国</code></p>
<ul>
<li>管理并维护超过300个计算节点的高性能计算集群</li>
<li>监控并报告近10起集群的潜在风险，包括宕机、断电和设备故障</li>
<li>修复超过100次集群的软硬件故障，如异常启动、挂载失灵等</li>
</ul>
<h2 id="出版物"><a href="#出版物" class="headerlink" title="出版物"></a>出版物</h2><p>梅宏, 金海等. 云计算: 信息社会的基础设施和服务引擎[M]. 中国科学技术出版社, ISBN 978-7-5046-8289-5.</p>
<h2 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h2><p><strong>语言:</strong></p>
<p><code>英语 (托福 100, GRE 322+4)</code>, <code>C语言</code>, <code>C++</code>, <code>Go</code>, <code>Python</code>, <code>HTML</code>, <code>Script</code>, <code>MySQL</code></p>
<p><strong>计算机体系架构:</strong></p>
<p><code>锁竞争</code>, <code>文件系统</code>, <code>Linux内核</code></p>
<p><strong>云计算:</strong></p>
<p><code>Docker</code>, <code>Kubernetes</code></p>
<p><strong>边缘计算:</strong></p>
<p><code>KubeEdge</code>, <code>服务网格</code></p>
<p><strong>机器学习:</strong></p>
<p><code>神经网络</code>, <code>优化算法</code></p>
<p><strong>可视化技术:</strong></p>
<p><code>数据挖掘</code>, <code>预测算法</code></p>
<h2 id="English"><a href="#English" class="headerlink" title="English"></a>English</h2><p><a href="https://github.com/xiaoli777/xiaoli777.github.io/blob/master/images/Xiaoli_Resume_English.pdf">https://github.com/xiaoli777/xiaoli777.github.io/blob/master/images/Xiaoli_Resume_English.pdf</a></p>
<h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><p><a href="https://github.com/xiaoli777/xiaoli777.github.io/blob/master/images/Xiaoli_Resume_Chinese.pdf">https://github.com/xiaoli777/xiaoli777.github.io/blob/master/images/Xiaoli_Resume_Chinese.pdf</a></p>
]]></content>
  </entry>
  <entry>
    <title>Windows GoLang</title>
    <url>/2021/Windows-GoLang/</url>
    <content><![CDATA[<h3 id="1-下载安装包，根据操作系统选择GoLang版本"><a href="#1-下载安装包，根据操作系统选择GoLang版本" class="headerlink" title="1. 下载安装包，根据操作系统选择GoLang版本"></a>1. 下载安装包，根据操作系统选择GoLang版本</h3><p>下载地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a></p>
<p><img src="/images/go/go-1.png"></p>
<h3 id="2-打开安装包，并根据提示安装GoLang"><a href="#2-打开安装包，并根据提示安装GoLang" class="headerlink" title="2. 打开安装包，并根据提示安装GoLang"></a>2. 打开安装包，并根据提示安装GoLang</h3><p>将安装路径设置为C:\Go\</p>
<p><img src="/images/go/go-2.png"></p>
<h3 id="3-打开cmd，查看GoLand是否安装成功"><a href="#3-打开cmd，查看GoLand是否安装成功" class="headerlink" title="3. 打开cmd，查看GoLand是否安装成功"></a>3. 打开cmd，查看GoLand是否安装成功</h3><p>win+R并输入cmd打开命令行界面，接着使用go version来查看GoLand的版本信息</p>
<p><img src="/images/go/go-3.png"></p>
<h3 id="4-创建mygo目录，并设置为GOPATH的系统变量"><a href="#4-创建mygo目录，并设置为GOPATH的系统变量" class="headerlink" title="4. 创建mygo目录，并设置为GOPATH的系统变量"></a>4. 创建mygo目录，并设置为GOPATH的系统变量</h3><p><img src="/images/go/go-4.png"></p>
]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>KubeEdge Installation</title>
    <url>/2021/KubeEdge-Installation/</url>
    <content><![CDATA[<h2 id="机器配置"><a href="#机器配置" class="headerlink" title="机器配置"></a>机器配置</h2><table>
<thead>
<tr>
<th>主机名</th>
<th>角色</th>
<th>IP</th>
<th>系统</th>
</tr>
</thead>
<tbody><tr>
<td>ecs-0004</td>
<td>Cloud</td>
<td>192.168.0.239</td>
<td>CentOS 8.0 6U6G</td>
</tr>
<tr>
<td>ecs-0005</td>
<td>Edge</td>
<td>192.168.0.211</td>
<td>CentOS 8.0 6U6G</td>
</tr>
</tbody></table>
<p><strong>注1：</strong>两台机器均已安装Docker，以及K8s工具。此外，将Cloud节点配置为K8s Master，并安装flannel网络（参考博客 <a href="https://xiaoli777.github.io/2021/Kubernetes-Installation/">Kubernetes Installation</a>）。</p>
<p><strong>注2：</strong>由于仅有部分版本的K8s对KubeEdge支持，因此安装K8s工具时，需要选择相应的版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install -y kubelet-1.17.0-0.x86_64 kubeadm-1.17.0-0.x86_64 kubectl-1.17.0-0.x86_64 --disableexcludes=kubernetes</span></span><br></pre></td></tr></table></figure>


<h2 id="禁用Edge节点的flannel网络"><a href="#禁用Edge节点的flannel网络" class="headerlink" title="禁用Edge节点的flannel网络"></a>禁用Edge节点的flannel网络</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl edit daemonset.apps/kube-flannel-ds -n kube-system</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/ke-001.png"></p>
<h2 id="下载并配置keadm"><a href="#下载并配置keadm" class="headerlink" title="下载并配置keadm"></a>下载并配置keadm</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://github.com/kubeedge/kubeedge/releases/download/v1.6.1/keadm-v1.6.1-linux-amd64.tar.gz</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/ke-002.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -zxvf keadm-v1.6.1-linux-amd64.tar.gz</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/ke-003.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp ./keadm-v1.6.1-linux-amd64/keadm/keadm /usr/bin/</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/ke-004.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/ke-005.png"></p>
<h2 id="使用keadm来安装Cloud节点"><a href="#使用keadm来安装Cloud节点" class="headerlink" title="使用keadm来安装Cloud节点"></a>使用keadm来安装Cloud节点</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> keadm init --advertise-address=<span class="string">&quot;THE-EXPOSED-IP&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/ke-006.png"></p>
<h2 id="将Edge节点加入到KubeEdge集群"><a href="#将Edge节点加入到KubeEdge集群" class="headerlink" title="将Edge节点加入到KubeEdge集群"></a>将Edge节点加入到KubeEdge集群</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scp /root/.kube/config root@192.168.0.211:/root/.kube/</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/ke-007.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> keadm gettoken</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/ke-008.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> keadm join --cloudcore-ipport=<span class="string">&quot;THE-EXPOSED-IP&quot;</span>:<span class="string">&quot;PORT&quot;</span> --token=<span class="string">&quot;TOKEN&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/ke-009.png"></p>
<h2 id="查看Edgecore是否开启，以及Edge节点是否加入集群"><a href="#查看Edgecore是否开启，以及Edge节点是否加入集群" class="headerlink" title="查看Edgecore是否开启，以及Edge节点是否加入集群"></a>查看Edgecore是否开启，以及Edge节点是否加入集群</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl status edgecore.service</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/ke-010.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/ke-011.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kubeedge.io/zh/docs/kubeedge/">https://kubeedge.io/zh/docs/kubeedge/</a></p>
<p><a href="https://github.com/kubeedge/kubeedge">https://github.com/kubeedge/kubeedge</a></p>
]]></content>
      <categories>
        <category>Edge Computing</category>
      </categories>
      <tags>
        <tag>KubeEdge</tag>
        <tag>Containerization</tag>
      </tags>
  </entry>
  <entry>
    <title>The Introduction of Istio</title>
    <url>/2021/The-Introduction-of-Istio/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Istio是一个与Kubernetes紧密结合的适用于云原生场景的Service Mesh形态的用于服务治理的开放平台。根据官方介绍，Istio的服务治理涉及连接（Connect）、安全（Secure）、策略执行（Control）和可观察性（Observe），如图所示。</p>
<img src="/images/kube/istio-001.png" style="zoom:60%;" /> 

<ul>
<li><strong>连接：</strong>Istio 通过集中配置的流量规则控制服务间的流量和调用，实现负载均衡、熔断、故障注入、重试、重定向等服务治理功能</li>
<li><strong>安全：</strong>Istio 提供透明的认证机制、通道加密、服务访问授权等安全能力，可增强服务访问的安全性</li>
<li><strong>策略执行：</strong>Istio 通过可动态插拔、可扩展的策略实现访问控制、速率限制、配额管理、服务计费等能力</li>
<li><strong>可观察性：</strong>动态获取服务运行数据和输出，提供强大的调用链、监控和调用日志收集输出的能力。配合可视化工具，可方便运维人员了解服务的运行状况，发现并解决问题</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Istio服务网格的架构，从逻辑上分为数据平面和控制平面。</p>
<img src="/images/kube/istio-002.png" style="zoom:60%;" />

<ul>
<li><strong>数据平面：</strong>由一组智能代理（Envoy）组成。这些代理负责协调和控制微服务之间的所有网络通信。它们还收集和报告所有网络流量的遥测数据</li>
<li><strong>控制平面：</strong>包括Pilot、Galley、Citadel等服务组件，用于管理并配置代理来精细化的流量控制</li>
</ul>
<p>具体而言，Istio中每个核心组件如下：</p>
<ul>
<li><strong>Envoy</strong>是唯一与数据平面流量交互的Istio组件，用于协调服务网格中所有服务的入站和出站流量</li>
<li><strong>Pilot</strong>将流量控制行为的高级路由规则转换为特定的环境配置，并在运行时将它们传播到Sidercar。并且，Pilot将特定于平台的服务发现机制抽象出来，并将它们合成为任何符合Envoy API的Sidercar都可以使用的标准格式</li>
<li><strong>Citadel</strong>通过内置的身份和证书管理，可以支持强大的服务到服务以及最终用户的身份验证</li>
<li><strong>Galley</strong>是Istio的配置验证、提取、处理和分发组件。它负责将其余的Istio组件与从底层平台（例如Kubernetes）获取用户配置的细节隔离开来</li>
</ul>
<p><strong>Istio的架构决定其部署形态：</strong></p>
<p>Istio的流量管理、遥测、治理等功能，均需要通过下发配置规则到应用所在的运行环境并执行才能生效。而负责执行这些配置规则的组件在服务网格中被称为服务代理，这些承载这些服务代理的实体称为Sidercar。应用程序发送或接收的流量都被sidecar拦截，并由sidecar进行认证、授权、策略执行及遥测数据上报等众多治理功能。</p>
<img src="/images/kube/istio-003.jpg" style="zoom:30%;" />

<p>从单个应用来看，sidecar与应用程序的解耦带来的应用完全无侵入、开发语言无关等特点解除了开发语言的约束，从而极大降低了应用开发者的开发成本。</p>
<p><strong>Istio提供更细粒度的控制：</strong></p>
<p>Istio的服务发现先从Kube-apiserver中获取Service和Endpoint，在将其转换成Istio服务模型的Service和ServiceInstance，但其数据面组件不再是Kube-proxy，而是部署在每个Pod里的Sidercar，即每个服务实例的Proxy。通过这种方式，Proxy和服务实例的关系更加紧密，从而提供更精细化的流量控制。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">子功能</th>
<th align="center">Istio 1.9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Sidercar自动注入</td>
<td align="center"></td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center">服务发现</td>
<td align="center"></td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center">流量拦截</td>
<td align="center">HTTP流量</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">TLS流量</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">TCP流量</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">UDP流量</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">SCTP流量</td>
<td align="center"><code>-</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">gRPC流量</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Websocket</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Websocket Secure</td>
<td align="center"><code>-</code></td>
</tr>
<tr>
<td align="center">流量治理</td>
<td align="center">负载均衡</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">会话保持</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">动态路由规则</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">熔断限流</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">故障注入</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">灰度发布</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center">访问安全</td>
<td align="center">双向认证</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">通道加密</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">授权管理</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center">可观测性</td>
<td align="center">监控指标</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">调用链追踪</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">访问日志</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center">外部访问</td>
<td align="center"></td>
<td align="center"><code>✓</code></td>
</tr>
</tbody></table>
<p>注：</p>
<ul>
<li><code>✓</code> Istio版本所支持的功能</li>
<li><code>+</code> Istio版本不具备的功能，但在后续版本中会支持</li>
<li><code>-</code> Istio版本不具备的功能，或已弃用的功能</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://istio.io/latest/zh/">https://istio.io/latest/zh/</a></p>
<p>《云原生服务网格Istio：原理、实践、架构与源码解析》</p>
]]></content>
      <categories>
        <category>Edge Computing</category>
      </categories>
      <tags>
        <tag>ServiceMesh</tag>
        <tag>Kubernetes</tag>
        <tag>Istio</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Namespace</title>
    <url>/2021/Network-Namespace/</url>
    <content><![CDATA[<h2 id="Namespace的作用"><a href="#Namespace的作用" class="headerlink" title="Namespace的作用"></a>Namespace的作用</h2><p>隔离内核资源，分割全局系统资源，并装到抽象的独立空间里。Namespace包括：</p>
<p>文件系统挂载点 (Mount)</p>
<p>主机名 (UTS)</p>
<p>POSIX进程间通信消息队列 (IPC)</p>
<p>进程PID数字空间 (PID)</p>
<p>IP地址 (network)</p>
<p>userID数字空间 (user)</p>
<p>Linux的namespace给里面的进程造成两个错觉：</p>
<ol>
<li>它是系统里唯一的进程</li>
<li>它独享系统的所有资源</li>
</ol>
<p>Network namespace使得每个容器都有自己的虚拟网络设备（IP地址、路由表、端口范围、/proc/net目录等），并且容器里的进程可以放心地绑定在端口上而不必担心冲突，这就使得在一个主机上同时运行多个监听80端口的Web服务器变为可能。</p>
<h2 id="Network-namespace管理命令"><a href="#Network-namespace管理命令" class="headerlink" title="Network namespace管理命令"></a>Network namespace管理命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建新的netns</span></span><br><span class="line">ip netns add netns1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入netns1，并查询其网络配置</span></span><br><span class="line">ip netns exec netns1 ip link list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看系统中的netns</span></span><br><span class="line">ip netns list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除netns</span></span><br><span class="line">ip netns delete netns1</span><br></pre></td></tr></table></figure>
<p>注：删除操作并没有删除netns1，只是移除了netns1对应的挂载点。只要里面还有进程运行着，该network namespace便会一直存在。</p>
<h2 id="Network-namespace配置命令"><a href="#Network-namespace配置命令" class="headerlink" title="Network namespace配置命令"></a>Network namespace配置命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入netns1，并把设备状态设置成UP</span></span><br><span class="line">ip netns exec netns1 ip link set dev lo up</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入netns1,并ping本地网卡</span></span><br><span class="line">ip netns exec netns1 ping 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一对虚拟以太网卡</span></span><br><span class="line">ip link add veth0 type veth peer name veth1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将veth pair的一端放到netns1</span></span><br><span class="line">ip link set veth1 netns netns1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为veth pair绑定ip，并设置成UP状态</span></span><br><span class="line">ip netns exec netns1 ifconfig veth1 10.1.1.1/24 up</span><br><span class="line">ifconfig veth0 10.1.1.2/24 up</span><br></pre></td></tr></table></figure>


<p>不同network namespace之间的路由表和防火墙规则等也是隔离的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入netns1，并查询其路由表</span></span><br><span class="line">ip netns exec netns1 route</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入netns1，并iptables规则</span></span><br><span class="line">ip netns exec netns1 iptables -L</span><br></pre></td></tr></table></figure>


<p>用户可以随意将虚拟网络设备分配到自定义的network namespace里，而连接真实硬件的物理设备则只能放在系统的根network namespace。</p>
<p>Network namespace里的root进程能够本network namespace的虚拟网络设备分配到其他network namespace。但通常为了保证安全性，需要结合PID namespace和Mount namespace的隔离特征做到network namespace之间的完全不可达。</p>
<h2 id="Network-namespace-API的使用"><a href="#Network-namespace-API的使用" class="headerlink" title="Network namespace API的使用"></a>Network namespace API的使用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 只要在clone()设置标志位CLONE_NEW，系统就会创建一个新的对应类型的<span class="keyword">namespace</span>及一个新的进程，并将这个进程放入到这个新创建的<span class="keyword">namespace</span>中</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clone</span><span class="params">(<span class="keyword">int</span> (*child_func)(<span class="keyword">void</span> *), <span class="keyword">void</span> *child_stack, <span class="keyword">int</span> flags, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"># 往<span class="keyword">namespace</span>添加进程，通常与execve()结合</span><br><span class="line"><span class="meta"># nstype: 让调用者检查第一个参数fd指向的namespace是否符合要求，0表示不检查</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setns</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> nstype)</span></span>;</span><br><span class="line"></span><br><span class="line"># 先通过指定的flags创建相应的<span class="keyword">namespace</span>，再把这个进程挪到新创建的<span class="keyword">namespace</span>中</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unshare</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>每个Linux进程都拥有一个属于自己的/proc/PID/ns，这个目录下的每个文件都代表一个类型的namespace。</p>
<p><img src="/images/kube/ns-001.png"></p>
<p>如图所示，该目录下每一个文件都是一个特殊的符号链接文件。其主要用途有两点：</p>
<ol>
<li>确定某两个进程是否属于同一个namespace。</li>
<li>当打开这些文件时，只要文件描述符保持open状态，对应的namespace就会一直存在，哪怕这个namespace里的所有进程都终止运行了。</li>
</ol>
<p>注：一旦系统管理员禁用namespace中的网络设备，即使里面的进程拿到了一些特权，也无法与外界通信。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Kubernetes网络权威指南》</p>
]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>Containerization</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Veth Pair</title>
    <url>/2021/Veth-Pair/</url>
    <content><![CDATA[<h2 id="Veth-pair介绍"><a href="#Veth-pair介绍" class="headerlink" title="Veth pair介绍"></a>Veth pair介绍</h2><p>Veth是虚拟以太网（Virtual Ethernet）的缩写。</p>
<p>Veth pair一端发送的数据会在另一端接受。根据这一特性，veth pair常被用于跨network namespace之间的通信，即分别将veth pair的两端放在不同的namespace中。</p>
<img src="/images/kube/vp-001.jpg" style="zoom:50%;" />



<h2 id="Veth-pair配置命令"><a href="#Veth-pair配置命令" class="headerlink" title="Veth pair配置命令"></a>Veth pair配置命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一对虚拟以太网卡</span></span><br><span class="line">ip link add veth0 type veth peer name veth1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将veth pair的一端设置为up状态</span></span><br><span class="line">ip link set dev veth0 up</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为veth pair的一端绑定ip，并设置成up状态</span></span><br><span class="line">ifconfig veth0 10.1.1.2/24 up</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将veth pair的一端放到namespace中（重置状态）</span></span><br><span class="line">ip link set veth1 netns newns</span><br></pre></td></tr></table></figure>


<p>查询容器与主机的veth pair</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看iflink和ifindex文件对</span></span><br><span class="line">cat /sys/class/net/eth0/iflink</span><br><span class="line">cat /sys/class/net/veth8080528/ifindex</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用ip link查询</span></span><br><span class="line">ip link show eth0</span><br><span class="line">ip link show | grep if3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过ethtool -S查询</span></span><br><span class="line">ethtool -S eth0</span><br><span class="line">ip addr</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注：第一条命令运行在容器环境，第二条运行在主机环境</span></span><br></pre></td></tr></table></figure>


<p>Linux bridge ≈ 虚拟的网络交换机：除了跨机连接网络设备，任意的真实物理设备（如eth0）和虚拟设备（如veth pair和tap设备）都能连接到Linux bridge上。</p>
<ul>
<li>Linux网桥：多个端口，数据可以从如何端口进来，再通过MAC地址决定出口</li>
<li>Linux其它网络设备：只有两端，从一端进来的数据会从另一端出去（外网 -&gt; 物理网卡 -&gt; 内核协议栈）</li>
</ul>
<h2 id="Linux-bridge配置命令"><a href="#Linux-bridge配置命令" class="headerlink" title="Linux bridge配置命令"></a>Linux bridge配置命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建网桥</span></span><br><span class="line">ip link add name br0 type bridge</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">brctl addbr br0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将网桥设置为up状态</span></span><br><span class="line">ip link set br0 up</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将veth0连接到br0上</span></span><br><span class="line">ip link set dev veth0 master br0</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">brctl addif br0 veth0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前网桥上的网络设备</span></span><br><span class="line">bridge link</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">brctl show</span><br></pre></td></tr></table></figure>


<p>Br0和veth0相连后：</p>
<p>Br0和veth0之间为双向的通道</p>
<p>协议栈和veth0之间变成了单通道，协议栈能发送数据给veth0，但veth0从外面收到的数据不会转发给协议栈</p>
<p>Br0的MAC地址变成了veth0的MAC地址</p>
<img src="/images/kube/vp-002.png" style="zoom:100%;" />



<p>在veth0连接到网桥后，veth0的IP将变得没有意义（单向通道）。因此，需要将veth0的IP地址赋给Linux Bridge，之后将veth0视为一根网线。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除veth0的IP</span></span><br><span class="line">ip addr del 1.2.3.101/24 dev veth0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将veth0的IP配置给br0</span></span><br><span class="line">ip addr add 1.2.3.101/24 dev br0</span><br></pre></td></tr></table></figure>


<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将物理网卡添加到Linux bridge</span></span><br><span class="line">ip addr set dev eth0 master br0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看ip地址</span></span><br><span class="line">ip add</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看路由表</span></span><br><span class="line">route -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加默认网关</span></span><br><span class="line">ip route add default via 192.168.0.1</span><br></pre></td></tr></table></figure>


<p>注：以上实验需要打开veth0网卡的混杂模式。</p>
<p>混杂模式（Promiscuous mode）：一个网卡会把它接收的所有网络流量都交给CPU，而不是只把它向转交的部分给CPU。</p>
<p>在非混杂模式下，网卡只会接收目的MAC地址是它自己的单播帧，以及多播帧和广播帧。</p>
<p>在混杂模式下，网卡会接收经过它的所有帧。</p>
<h2 id="混杂模式命令"><a href="#混杂模式命令" class="headerlink" title="混杂模式命令"></a>混杂模式命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动网卡的混杂模式</span></span><br><span class="line">ifconfig eth0 promisc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出网卡的混杂模式</span></span><br><span class="line">ifconfig eth0 -promisc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网卡是否开启了混杂模式</span></span><br><span class="line">ifconfig</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">netstat -i</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 网络设备加入网桥后，会自动进入混杂模式，且无法退出</span></span><br><span class="line">brctl addif br0 veth0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 网络设备离开Linux bridge，会自动退出混杂模式</span></span><br><span class="line">brctl delif br0 veth0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看是否进入混杂模式</span></span><br><span class="line">dmesg | grep promiscuous</span><br></pre></td></tr></table></figure>


<h2 id="附代码"><a href="#附代码" class="headerlink" title="附代码"></a>附代码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@488dacbfe771 /]# ip netns add newns</span><br><span class="line">[root@488dacbfe771 /]# ip netns exec newns ip link set dev lo up</span><br><span class="line">[root@488dacbfe771 /]# ip link add veth0 type veth peer name veth1</span><br><span class="line">[root@488dacbfe771 /]# ip link set veth1 netns newns</span><br><span class="line">[root@488dacbfe771 /]# ip netns exec newns ifconfig veth1 10.1.1.1/24 up</span><br><span class="line">[root@488dacbfe771 /]# ifconfig veth0 10.1.1.2/24 up</span><br><span class="line">[root@488dacbfe771 /]# ping -c 1 -I veth0 10.1.1.1</span><br><span class="line">PING 10.1.1.1 (10.1.1.1) from 10.1.1.2 veth0: 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.1.1.1: icmp_seq=1 ttl=64 time=0.035 ms</span><br><span class="line"></span><br><span class="line">--- 10.1.1.1 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.035/0.035/0.035/0.000 ms</span><br><span class="line">[root@488dacbfe771 /]# </span><br><span class="line">[root@488dacbfe771 /]# ip link add name br0 type bridge</span><br><span class="line">[root@488dacbfe771 /]# ip link set br0 up</span><br><span class="line">[root@488dacbfe771 /]# ip link set dev veth0 master br0</span><br><span class="line">[root@488dacbfe771 /]# </span><br><span class="line">[root@488dacbfe771 /]# ping -c 1 -I veth0 10.1.1.1</span><br><span class="line">PING 10.1.1.1 (10.1.1.1) from 10.1.1.2 veth0: 56(84) bytes of data.</span><br><span class="line">^C</span><br><span class="line">--- 10.1.1.1 ping statistics ---</span><br><span class="line">1 packets transmitted, 0 received, 100% packet loss, time 0ms</span><br><span class="line"></span><br><span class="line">[root@488dacbfe771 /]# ip addr del 10.1.1.2/24 dev veth0</span><br><span class="line">[root@488dacbfe771 /]# ip addr add 10.1.1.2/24 dev br0</span><br><span class="line">[root@488dacbfe771 /]# ping -c 1 -I br0 10.1.1.1</span><br><span class="line">PING 10.1.1.1 (10.1.1.1) from 10.1.1.2 br0: 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.1.1.1: icmp_seq=1 ttl=64 time=0.040 ms</span><br><span class="line"></span><br><span class="line">--- 10.1.1.1 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">[root@488dacbfe771 /]#</span><br><span class="line">[root@488dacbfe771 /]# ip link set dev eth0 master br0</span><br><span class="line">[root@488dacbfe771 /]# ifconfig eth0 promisc</span><br><span class="line">[root@488dacbfe771 /]# ping -c 1 -I br0 1.2.3.102</span><br><span class="line">PING 1.2.3.102 (1.2.3.102) from 1.2.3.101 br0: 56(84) bytes of data.</span><br><span class="line">64 bytes from 1.2.3.102: icmp_seq=1 ttl=64 time=0.024 ms</span><br><span class="line"></span><br><span class="line">--- 1.2.3.102 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.024/0.024/0.024/0.000 ms</span><br><span class="line">[root@488dacbfe771 /]#</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Kubernetes网络权威指南》</p>
]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>Containerization</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Network</title>
    <url>/2021/Docker-Network/</url>
    <content><![CDATA[<h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><p>相比于传统虚拟化技术对硬件资源的虚拟，容器技术是对进程的虚拟，提供更轻量级的虚拟化，实现进程和资源的隔离，更接近裸机性能。</p>
<p>Docker容器使用Docker Engine进行资源分配调度并调用Linux内核namespace API进行隔离，所有应用共用主机操作系统。</p>
<h2 id="Docker-的四大网络模式"><a href="#Docker-的四大网络模式" class="headerlink" title="Docker 的四大网络模式"></a>Docker 的四大网络模式</h2><p>bridge模式：通过–network=bridge指定，使用Linux bridge和veth pair为Docker容器创建独立的网络栈，保证容器内的进程使用独立的网络环境，使容器和容器、容器和宿主机之间能实现网络隔离。</p>
<p>host模式：通过–network=host指定，容器和宿主机共享一个network namespace（网卡，IP和端口等）</p>
<p>container模式：通过–network=container:NAME_or_ID指定，新的容器将与一个已经存在容器共享network namespace，两个容器的进程可以通过lo网卡进行通信</p>
<p>none模式：通过–network=none指定，不对Docker容器的network namespace进行任何网络配置</p>
<h2 id="Docker网络配置"><a href="#Docker网络配置" class="headerlink" title="Docker网络配置"></a>Docker网络配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器IP</span></span><br><span class="line">docker inspect -f &quot;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&quot; &lt;containerNameOrId&gt;</span><br><span class="line">docker inspect &lt;containerNameOrId&gt; | grep &#x27;&quot;IPAddress&quot;&#x27; | grep -n 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 端口映射</span></span><br><span class="line">docker run -p host_Port:container_Port -d &lt;imageName&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 实现原理为在iptable的nat表中添加规则</span></span><br><span class="line">iptables -t nat -nL</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看端口映射</span></span><br><span class="line">docker port &lt;container&gt; &lt;port number&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问外网</span></span><br><span class="line">sysctl net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> DNS和主机名</span></span><br><span class="line">cat /etc/resolv.conf</span><br><span class="line">cat /etc/hosts</span><br><span class="line">cat /etc/hostname</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改dns</span></span><br><span class="line">docker run --dns=address -d &lt;imageName&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改主机名</span></span><br><span class="line">docker run -h hostname -d &lt;imageName&gt;</span><br><span class="line">docker run --hostname=hostname -d &lt;imageName&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建自定义网络</span></span><br><span class="line">docker network create -d bridge --subnet 172.25.0.0/16 netName</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看自定义网络信息</span></span><br><span class="line">ip addr</span><br><span class="line">docker inspect netID</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看主机的docker network</span></span><br><span class="line">docker network ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除自定义网络</span></span><br><span class="line">docker network rm netID</span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接容器和网络</span></span><br><span class="line">docker network connect netName_or_Id ContainerName_or_Id</span><br><span class="line"><span class="meta">#</span><span class="bash"> 断开容器和网络的连接（NetworkMode不会改变）</span></span><br><span class="line">docker network disconnect netName_or_Id ContainerName_or_Id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发布服务</span></span><br><span class="line">docker network create -d bridge netName</span><br><span class="line">docker service publish svcName.netName</span><br><span class="line">docker service attach containerId svcName.netName</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">docker run -itd --publish-service svcName.netName.bridge imageName</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器互联</span></span><br><span class="line">docker run -d imageName --link=containerName_or_Id:aliasName</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Kubernetes网络权威指南》</p>
]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>Containerization</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Tunnel -- ipip</title>
    <url>/2021/Linux-Tunnel-ipip/</url>
    <content><![CDATA[<h2 id="查看IP隧道相关操作"><a href="#查看IP隧道相关操作" class="headerlink" title="查看IP隧道相关操作"></a>查看IP隧道相关操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip tunnel <span class="built_in">help</span></span><br></pre></td></tr></table></figure>


<h2 id="Linux原生L3隧道支持"><a href="#Linux原生L3隧道支持" class="headerlink" title="Linux原生L3隧道支持"></a>Linux原生L3隧道支持</h2><p>ipip: IPv4 in IPv4</p>
<p>GRE: Generic Routing Encapsulation</p>
<p>sit: IPv6 over IPv4</p>
<p>ISATAP: Intra-Site Automatic Tunnel Addressing Protocol, IPv6</p>
<p>VTI: Virtual Tunnel Interface</p>
<h2 id="容器构建ipip隧道"><a href="#容器构建ipip隧道" class="headerlink" title="容器构建ipip隧道"></a>容器构建ipip隧道</h2><p>加载ipip模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ modprobe ipip</span><br><span class="line">$ lsmod | grep ipip</span><br><span class="line">ipip                   16384  0</span><br><span class="line">tunnel4                16384  1 ipip</span><br><span class="line">ip_tunnel              28672  1 ipip</span><br></pre></td></tr></table></figure>


<p>打开Ipv4转发功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">$ cat /proc/sys/net/ipv4/ip_forward</span><br><span class="line">1</span><br></pre></td></tr></table></figure>


<p>启动特权CentOS容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it --privileged=<span class="literal">true</span> centos bash</span><br></pre></td></tr></table></figure>


<p>安装网络工具组件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install net-tools</span><br></pre></td></tr></table></figure>


<p>构建net namesapce、veth pair以及相关IP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip netns add ns1</span><br><span class="line">$ ip netns add ns2</span><br><span class="line">$ ip link add v1 <span class="built_in">type</span> veth peer name v1_p</span><br><span class="line">$ ip link add v2 <span class="built_in">type</span> veth peer name v2_p</span><br><span class="line"></span><br><span class="line">$ ip link <span class="built_in">set</span> v1 netns ns1</span><br><span class="line">$ ip link <span class="built_in">set</span> v2 netns ns2</span><br><span class="line"></span><br><span class="line">$ ip addr add 10.10.10.1/24 dev v1_p</span><br><span class="line">$ ip link <span class="built_in">set</span> v1_p up</span><br><span class="line">$ ip addr add 10.10.20.1/24 dev v2_p</span><br><span class="line">$ ip link <span class="built_in">set</span> v2_p up</span><br><span class="line"></span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns1 ip addr add 10.10.10.2/24 dev v1</span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns1 ip link <span class="built_in">set</span> v1 up</span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns2 ip addr add 10.10.20.2/24 dev v2</span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns2 ip link <span class="built_in">set</span> v2 up</span><br></pre></td></tr></table></figure>


<p>这时，使用v1 ping v2还不通。查看ns1路由表，发现缺少10.10.20.0/24网段的路由。ns2的路由表同理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip netns <span class="built_in">exec</span> ns1 route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.10.10.0      0.0.0.0         255.255.255.0   U     0      0        0 v1</span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns2 route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.10.20.0      0.0.0.0         255.255.255.0   U     0      0        0 v2</span><br></pre></td></tr></table></figure>


<p>配置相关路由，再使用v1 ping v2，通！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip netns <span class="built_in">exec</span> ns1 route add -net 10.10.20.0 netmask 255.255.255.0 gw 10.10.10.1</span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns2 route add -net 10.10.10.0 netmask 255.255.255.0 gw 10.10.20.1</span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns1 ping -c 1 -I v1 10.10.20.2</span><br><span class="line">PING 10.10.20.2 (10.10.20.2) from 10.10.10.2 v1: 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.10.20.2: icmp_seq=1 ttl=63 time=0.018 ms</span><br><span class="line"></span><br><span class="line">--- 10.10.20.2 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.018/0.018/0.018/0.000 ms</span><br></pre></td></tr></table></figure>


<p>配置ipip隧道，以及隧道内外层ip</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip netns <span class="built_in">exec</span> ns1 ip tunnel add tun1 mode ipip remote 10.10.20.2 <span class="built_in">local</span> 10.10.10.2</span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns1 ip link <span class="built_in">set</span> tun1 up</span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns1 ip addr add 10.10.100.10 peer 10.10.200.10 dev tun1</span><br><span class="line"></span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns2 ip tunnel add tun2 mode ipip remote 10.10.10.2 <span class="built_in">local</span> 10.10.20.2</span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns2 ip link <span class="built_in">set</span> tun2 up</span><br><span class="line">$ ip netns <span class="built_in">exec</span> ns2 ip addr add 10.10.200.10 peer 10.10.100.10 dev tun2</span><br></pre></td></tr></table></figure>


<p>使用隧道进行通信</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip netns <span class="built_in">exec</span> ns1 ping -c 1 -I tun1 10.10.200.10 </span><br><span class="line">PING 10.10.200.10 (10.10.200.10) from 10.10.100.10 tun1: 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.10.200.10: icmp_seq=1 ttl=64 time=0.040 ms</span><br><span class="line"></span><br><span class="line">--- 10.10.200.10 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.040/0.040/0.040/0.000 ms</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Kubernetes网络权威指南》</p>
]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>Containerization</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>星云文件系统简介</title>
    <url>/2021/%E6%98%9F%E4%BA%91%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="位置寻址-VS-内容寻址"><a href="#位置寻址-VS-内容寻址" class="headerlink" title="位置寻址 VS 内容寻址"></a>位置寻址 VS 内容寻址</h2><p><strong>位置寻址</strong>指向特定实体所存储的数据位置。</p>
<p>位置寻址的两个缺陷：</p>
<ol>
<li><p>可信度: 难以验证内容存储的URL，以及内容是否与中心权威机构相关</p>
</li>
<li><p>效率: 不同域上或不同文件名的相同内容导致大量的冗余</p>
</li>
</ol>
<p><strong>内容寻址</strong>为数据提供独特的，内容驱动的标识符，我们可以用这些标识符去检索数据:</p>
<ol>
<li><p>结合加密哈希，内容寻址不在依赖于权威机构：即使改变非常小（一个图像中的一个像素点的改变），加密算法也会产生完全不同的哈希值</p>
</li>
<li><p>加密哈希能够从数据的内容中产生，意味着任何人对相同数据使用相同算法将产生相同的哈希值</p>
</li>
</ol>
<h2 id="内容标识符-CIDs"><a href="#内容标识符-CIDs" class="headerlink" title="内容标识符 (CIDs)"></a>内容标识符 (CIDs)</h2><p>内容标识符是自描述型的内容寻址标识符。它不能表示内容在哪儿存储，但它基于内容本身形成了一个地址。</p>
<p>多哈希是自描述型哈希值，它本身包含描述加密算法和哈希长度的元数据。</p>
<img src="/images/fs/ifps-001.jpg" style="zoom:50%;" />

<ul>
<li>algo: 用于生成哈希值的<strong>加密算法</strong>标识符</li>
<li>length: 哈希值的实际<strong>长度</strong></li>
<li>value: 实际<strong>哈希值</strong></li>
</ul>
<p>在添加<strong>加密方式</strong>（dag-pd）和<strong>版本前缀</strong>后（version 1），最终的CID将如下所示：</p>
<p><code>&lt;cid-version&gt;</code> <code>&lt;multicodec&gt;</code> <code>&lt;multihash-algorithm&gt;</code> <code>&lt;multihash-length&gt;</code> <code>&lt;multihash-hash&gt;</code></p>
<img src="/images/fs/ifps-002.png" style="zoom:30%;" />



<h2 id="Merkle-DAGs-有向无环图"><a href="#Merkle-DAGs-有向无环图" class="headerlink" title="Merkle DAGs (有向无环图)"></a>Merkle DAGs (有向无环图)</h2><p>IPFS使用CIDs去唯一地表示一个节点，并使用Merkle DAGs去表示从一个节点到另一个节点的边。</p>
<img src="/images/fs/ifps-003.svg" style="zoom:80%;" />

<p>在Merkle DAG中，每个节点的CID都依赖于它的每一个后代节点；如果任何后代节点出现不同，他们的标识符也会不同。例如，如果图片tabby猫被修改，则它在图中相应的节点会接受到不同的CID。这意味着，我们总要自上而下构建DAG：在子节点的CID未被决定前，父节点不能被创建。</p>
<p>在Merkle DAG中，每个节点的CID依赖于它的每一个孩子节点。因此，根节点的CID可以表示整个有向无环图。</p>
<p>IPFS的Merkle DAGs有三个特点：</p>
<p><strong>可验证性</strong>：需要检索数据的节点可以验证它的CID</p>
<p><strong>分布性</strong>：1) 任何拥有DAG的人可以作为该DAG的提供者; 2) 我们能够并行检索数据以及它的孩子节点</p>
<p><strong>去重性</strong>：通过将冗余部分加密为链接，Merkle DAGs能高效地存储数据</p>
<h2 id="分布式哈希表-DHT"><a href="#分布式哈希表-DHT" class="headerlink" title="分布式哈希表 (DHT)"></a>分布式哈希表 (DHT)</h2><p>为了寻找所需内容的节点，IPFS使用<strong>分布式哈希表</strong>，即 <strong>DHT</strong>。IPFS使用 <strong><a href="https://libp2p.io/">libp2p</a></strong> 去提供 DHT，并处理节点间的连接以及交流。</p>
<p>一旦知晓所需内容的节点，将再次使用 DHT 来查询这些节点（路由）的位置。因此，为了得到该内容，需要使用两次 libp2p 来查询 DHT。</p>
<p>在发现所需内容及其位置后，需要连接到该内容并交换。为了请求所需块并向其它节点发送块，IPFS当前使用 <strong>BitSwap</strong> 模块。Bitswap 允许连接到所需内容的节点，向它们发送 <strong>wantlist</strong> (所需块的列表)，并让它们发生请求块。一旦这些块到达，使用它们的CIDs进行验证。</p>
<h2 id="Libp2p"><a href="#Libp2p" class="headerlink" title="Libp2p"></a>Libp2p</h2><p>libp2p是IPFS的网络栈。libp2p的目标是解决p2p连接中的发现能力。但是，libp2p已从IPFS中剥离出来，两个项目分别有各自的目标：</p>
<ul>
<li>IPFS更多关注内容寻址，例如，查找、提取和验证web中的每个内容块</li>
<li>libp2p更多关注过程寻址，例如，查找、链接和验证任何数据在网络中的转移过程</li>
</ul>
<p>libp2p通过<strong>模块化</strong>实现过程寻址，即定制用户样例——用户能够根据自己的需求来选择特定的模块（传输、网络地址转换等），并组成相关的配置。</p>
<p>以<strong>OSI模型</strong>（开放系统互连模型）作为例子。</p>
<img src="/images/fs/ifps-004.png" style="zoom:20%;" />

<p>正如我们所示，在web中的实际实现并没有完全遵循OSI模型，并且比较混乱。例如，上图所示的TCP/IP协议。</p>
<p>Instead, libp2p breaks the OSI Model apart and allows applications to mix and match freely without being restricted to rigid conceptual models.</p>
<p>但是，libp2p分解了OSI模型，并使得应用程序不再受概念模型的制约，能够自由地组合。</p>
<img src="/images/fs/ifps-005.png" style="zoom:50%;" />

<p>如上左图所示，<strong>NodeJs</strong> libp2p配置文件：</p>
<ul>
<li>第一部分导入组成网络栈所有需要的libp2p模块</li>
<li>第二部分是libp2p节点配置，在这里我们为每个网络块添加不同模块</li>
</ul>
<p>但是，对于运行在<strong>浏览器</strong>中的代码（<strong>不需要支持TCP传输</strong>），我们只需要在libp2p配置中改变<strong>传输协议</strong>和<strong>对等发现协议</strong>。</p>
<h2 id="Filecoin"><a href="#Filecoin" class="headerlink" title="Filecoin"></a>Filecoin</h2><p>Filecoin添加激励层，来促进在去中心化web中长期、可验证的存储。由于Filecoin的区块，网络中的所有参与者共同工作来验证交易。在没有中心权威机构时，这些共识机制使得分布式网络中的用户能够达成一致。</p>
<p>在Filecoin中，存储矿工负责验证他们是否存储了正确的数据，验证器的功能被网络中的所有参与者所共享。</p>
<p>在系统文件（如puppy.gif）能被Filecoin网络共享前，它必须将自己转化为Filecoin块：</p>
<ul>
<li>第一阶段，系统文件被分割来创建IPLD DAG</li>
<li>第二阶段，IPLD DAG被序列化为CAR文件，并填充来生产Filecoin块</li>
</ul>
<img src="/images/fs/ifps-006.png" style="zoom:45%;" />

<p>在存储的协商过程中，CID和其它交易参数合并来生产一个交易协议。接着，客户端发送该协议到存储数据的矿工。一旦矿工确认该协议，客户端向矿工传输数据。一旦矿工传输数据，并验证这些数据匹配协议中的CID，它们就向Filecoin的区块中发送交易协议，来提交协议块。</p>
<p>**重复证明 (PoRep)**：存储矿工验证存储的数据块是唯一的。重复证明只在数据第一次被矿工存储时发生一次</p>
<p><strong>时空证明 (PoSt)</strong>: 重复地验证存储空间中是否有相同的数据</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>ProtoSchool: <a href="https://proto.school/">https://proto.school/</a></p>
<p>IPFS Docs: <a href="https://docs.ipfs.io/">https://docs.ipfs.io/</a></p>
]]></content>
      <categories>
        <category>File System</category>
      </categories>
      <tags>
        <tag>IPFS</tag>
      </tags>
  </entry>
</search>
