<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Binary tree</title>
    <url>/2021/Binary-tree/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><a href="https://en.wikipedia.org/wiki/Binary_tree">二叉树(Binary Tree)</a>是一种数据结构，它的每个父节点(parent)至多有两个子节点(children)，分别被称为<em>左孩子(the left child)<em>和</em>右孩子(the right child)</em>.</p>
<p><img src="/images/bt/bt-1.png"></p>
<p>如上图所示, 该二叉树的大小(size)为9且高度(height)为3，根结点(root)的值为2. 另外，这是一棵不平衡(unbalanced)且未排序(unsorted)的二叉树。</p>
<br>

<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><ul>
<li><p><strong>满二叉树(full binary tree)</strong></p>
<ul>
<li><p>除叶子节点(leaf)外，所有分支节点都含有2个非空子节点的二叉树</p>
</li>
<li><p>满二叉树上的节点要么有0个子节点，要么有2个子节点</p>
</li>
<li><p>满二叉树的子树(subtree)是单个顶点(vertex)，或同样是满二叉树</p>
<p><img src="/images/bt/bt-2.png"></p>
</li>
</ul>
</li>
<li><p><strong>完全二叉树(complete binary tree)</strong></p>
<ul>
<li><p>除了最后一层，其余层都是“满”的，且叶子节点尽可能向左靠齐</p>
</li>
<li><p>or 在最后一层中，移除最右边的叶子节点(rightmost leaves)</p>
</li>
<li><p>完全二叉树节点总数在1 ～ $2^h$ 之间，其中h为树的高度</p>
<p><img src="/images/bt/bt-3.png"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>完美二叉树(perfect binary tree)</strong><ul>
<li>完全二叉树 + 满二叉树</li>
</ul>
</li>
</ul>
<br>

<h2 id="二叉树属性"><a href="#二叉树属性" class="headerlink" title="二叉树属性"></a>二叉树属性</h2><ul>
<li><strong>在任意二叉树中，度数为2节点的个数等于叶子节点的个数减1</strong></li>
</ul>
<p>节点的度数等于其子节点的个数。因此，在二叉树中，节点的度数只可能为0，1和2。</p>
<p>当只有1个节点时，度为0。接着，每多出1个节点，同时会派生出1度。派生出的度和派生出的节点数一定相等。即：</p>
<p><code>节点总数 = 总度数 + 1</code></p>
<p>假设在一棵二叉树中，度数为2的节点数为<code>X2</code>，度数为1的节点数为<code>X1</code>，度数为0的节点数为<code>X0</code>。结合上式：</p>
<p><code>X2 + X1 + X0 = 2X2 + X1 + 1</code>，推出 <code>X2 = X0 - 1</code></p>
<p>因此，<strong>度数为2的节点个数等于叶节点数减1</strong></p>
<ul>
<li><strong>满二叉树定理：非空满二叉树的叶节点数等于其分支节点数加1</strong></li>
</ul>
<p>证明同上。在满二叉树中，度数为1的节点数为0。</p>
<ul>
<li><strong>一颗非空二叉树中，空子树的数目等于其节点数目加1</strong></li>
</ul>
<p>当仅有根节点时：二叉树有2个空子树，1个节点，结论成立。</p>
<p>接着，空子树和节点等量增长，结论成立。</p>
<ul>
<li><strong>满二叉树最少有2h+1个节点，最多有2^(h+1)-1个节点 (仅有根节点的二叉树的高度为0)</strong></li>
<li><strong>在完美二叉树中，假设叶子结点的个数为l，高度为h，则l=2^h，总结点个数n=2^(h+1)-1</strong></li>
</ul>
<br>

<h2 id="二叉树算法"><a href="#二叉树算法" class="headerlink" title="二叉树算法"></a>二叉树算法</h2><h4 id="二叉树的结点"><a href="#二叉树的结点" class="headerlink" title="二叉树的结点"></a>二叉树的结点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    elemType info;</span><br><span class="line">    binaryTreeNode&lt;elemType&gt; *left;</span><br><span class="line">    binaryTreeNode&lt;elemType&gt; *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的高度"><a href="#二叉树的高度" class="headerlink" title="二叉树的高度"></a>二叉树的高度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(binaryTreeNode&lt;elemType&gt; *btn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (btn == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(height(btn-&gt;left), height(btn-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的复制"><a href="#二叉树的复制" class="headerlink" title="二叉树的复制"></a>二叉树的复制</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyTree</span><span class="params">(binaryTreeNode&lt;elemType&gt;* &amp;copiedTreeRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">		binaryTreeNode&lt;elemType&gt;* otherTreeRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (otherTreeRoot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        copiedTreeRoot = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        copiedTreeRoot = <span class="keyword">new</span> binaryTreeNode&lt;elemType&gt;;</span><br><span class="line">        copiedTreeRoot-&gt;info = otherTreeRoot-&gt;info;</span><br><span class="line">        copyTree(copiedTreeRoot-&gt;left, otherTreeRoot-&gt;left);</span><br><span class="line">        copyTree(copiedTreeRoot-&gt;right, otherTreeRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的遍历-traverse"><a href="#二叉树的遍历-traverse" class="headerlink" title="二叉树的遍历 (traverse)"></a>二叉树的遍历 (traverse)</h4><ul>
<li><strong>前序</strong>遍历：根-&gt;左-&gt;右</li>
<li><strong>中序</strong>遍历：左-&gt;根-&gt;右</li>
<li><strong>后序</strong>遍历：左-&gt;右-&gt;根</li>
</ul>
<h5 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(binaryTreeNode&lt;elemType&gt; *btn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (btn == <span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; btn-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    preorder(btn-&gt;left);</span><br><span class="line">    preorder(btn-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(binaryTreeNode&lt;elemType&gt; *btn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (btn == <span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line">    inorder(btn-&gt;left);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; btn-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    inorder(btn-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(binaryTreeNode&lt;elemType&gt; *btn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (btn == <span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line">    postorder(btn-&gt;left);</span><br><span class="line">    postorder(btn-&gt;right);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; btn-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h5><p>需要额外的一个栈stack结构来辅助实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorderIteration</span><span class="params">(binaryTreeNode&lt;elemType&gt; *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;binaryTreeNode&lt;elemType&gt;*&gt; st;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        st.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">        binaryTreeNode&lt;elemType&gt; *cur = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cur-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//操作当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">            st.push(cur-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">            st.push(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderIteration</span><span class="params">(binaryTreeNode&lt;elemType&gt; *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;binaryTreeNode&lt;elemType&gt;*&gt; st;</span><br><span class="line"></span><br><span class="line">    binaryTreeNode&lt;elemType&gt; *cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur || !st.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">            st.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cur-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//操作当前节点</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderIteration</span><span class="params">(binaryTreeNode&lt;elemType&gt; *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;binaryTreeNode&lt;elemType&gt;*&gt; st;</span><br><span class="line">    binaryTreeNode&lt;elemType&gt; *pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        st.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">        binaryTreeNode&lt;elemType&gt; *cur = st.top();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 出栈条件：</span></span><br><span class="line"><span class="comment">         * 对于叶子节点：直接弹出</span></span><br><span class="line"><span class="comment">         * 对于非叶子节点：如果已经遍历过其左子节点或右子节点，则弹出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>((!cur-&gt;left &amp;&amp; !cur-&gt;right) || (pre &amp;&amp; (cur-&gt;left == pre || cur-&gt;right == pre)))&#123;</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cur-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//操作当前节点</span></span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//说明是一个非叶子节点，并且还未访问其左右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                st.push(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                st.push(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="层次遍历-Breadth-First-Search"><a href="#层次遍历-Breadth-First-Search" class="headerlink" title="层次遍历 (Breadth-First Search)"></a>层次遍历 (Breadth-First Search)</h5><p>需要额外的一个队列queue结构来辅助实现。</p>
<p>大致思想为：队列初始化时只有根节点，每个节点出队列时，将它子节点加入队列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(binaryTreeNode&lt;elemType&gt;* btn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(btn == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">queue</span>&lt;binaryTreeNode&lt;elemType&gt; *&gt; que; <span class="comment">//构造一个树结点指针的队列</span></span><br><span class="line">    que.push(btn);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        binaryTreeNode&lt;elemType&gt; *q = que.front();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        que.pop();</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;left != <span class="literal">nullptr</span>)  <span class="comment">//左子节点入队列</span></span><br><span class="line">            que.push(q-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;right != <span class="literal">nullptr</span>)  <span class="comment">//右子节点入队列</span></span><br><span class="line">            que.push(q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉树的算法思路：<strong>仅考虑当前结点的任务，将其余部分交给递归或迭代框架。</strong>其算法框架大致为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">elemType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTFramework</span><span class="params">(binaryTreeNode&lt;elemType&gt;* btn, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (btn-&gt;val == target)</span><br><span class="line">        DoSometing;</span><br><span class="line">    <span class="keyword">if</span> (btn-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">        BTFramework(btn-&gt;left, target);</span><br><span class="line">    <span class="keyword">if</span> (btn-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">        BTFramework(btn-&gt;right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个以后再细说。。。</p>
<p>代码下载地址：<a href="https://xiaoli777.github.io/codes/BinaryTree.cpp">https://xiaoli777.github.io/codes/BinaryTree.cpp</a></p>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Common Knowledge of Camera</title>
    <url>/2020/Common-Knowledge-of-Camera/</url>
    <content><![CDATA[<h4 id="数码单镜头反光相机-DSLR-组成"><a href="#数码单镜头反光相机-DSLR-组成" class="headerlink" title="数码单镜头反光相机(DSLR)组成"></a>数码单镜头反光相机(DSLR)组成</h4><ul>
<li>五棱镜</li>
<li>取景器目镜</li>
<li>感光元件(CMOS)</li>
<li>快门</li>
<li>反光板</li>
</ul>
<h4 id="相机画幅"><a href="#相机画幅" class="headerlink" title="相机画幅"></a>相机画幅</h4><ul>
<li><strong>全画幅(36mm * 24mm):</strong> 感光元件大、成像质量好</li>
<li><strong>非全幅(23mm * 15mm, APS-C):</strong> 小型化、低成本</li>
</ul>
<h4 id="视角"><a href="#视角" class="headerlink" title="视角"></a>视角</h4><ul>
<li><p>从感光元件(像方焦平面)对角线的两端至镜头主点连线之间的夹角</p>
</li>
<li><p>视角角度的大小决定了被摄物体的成像范围</p>
</li>
</ul>
<h4 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h4><ul>
<li><p>照片的分辨率，像素越高，获得的照片尺寸越大</p>
</li>
<li><p>在相同的像素下，感光元件尺寸越大，单个像素的感光面积就越大，能捕获的光子就越多，记录的暗部细节和亮部细节就越丰富，其画质也就越好</p>
</li>
<li><p>相同尺寸的感光元件，其像素越高，单个像素的感光面积就越小，受到的干扰就越大，噪点也就越大，画质反而会下降</p>
</li>
</ul>
<h4 id="对焦系统"><a href="#对焦系统" class="headerlink" title="对焦系统"></a>对焦系统</h4><ul>
<li><strong>对焦点数:</strong> 取景器里所能看到的对焦点的数量，对焦点越多，构图越方便</li>
<li><strong>对焦精度:</strong> 十字型对焦点数的多少</li>
<li><strong>十字型:</strong> 对焦点对横、竖方向都敏感，对较准确</li>
<li><strong>一字型:</strong> 对焦点只对单向(纵、横)敏感，没有十字型对焦点准确</li>
</ul>
<h4 id="高感性能"><a href="#高感性能" class="headerlink" title="高感性能"></a>高感性能</h4><ul>
<li><p>感光度(ISO)越高，画面噪点越多，画质越差</p>
</li>
<li><p>高感光度性能的强弱对拍摄弱光环境下的题材尤为重要</p>
</li>
</ul>
<h4 id="连拍速度"><a href="#连拍速度" class="headerlink" title="连拍速度"></a>连拍速度</h4><ul>
<li><p>每秒拍摄照片的张数</p>
</li>
<li><p>连拍速度越快，越容易捕捉到精彩的瞬间</p>
</li>
</ul>
<h4 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h4><ul>
<li><strong>Av档:</strong> 光圈优先模式。在手动确定相机光圈的情况下，相机自动根据光圈值大小及当时环境找到最佳的快门速度，这种模式多用于拍摄人像及风光。我们知道光圈直接影响着景深，当我们拍摄人像需要浅景深时，就可以通过自定义大光圈，相机自动匹配快门速度，可以在很快情况下找到合适的曝光</li>
<li><strong>Tv档:</strong> 快门优先模式。即我们手动设置好快门速度，相机根据快门速度来确定最佳光圈值。快门优先模式一般用于拍摄运动的物体，例如体育比赛、水流、舞蹈中的人以及飞行中的物体等。拍摄运动物体最容易出现的问题是即使对了焦，照片也容易模糊，这是由于相机快门速度没有跟上被摄物体的运动速度导致的</li>
<li><strong>P档</strong>: 半自动档，与AUTO档不同的是它允许我们手动设置曝光补偿、ISO感光度等。在设置后相机自动匹配出最佳的光圈值和快门速度，特别适合用来抓拍。如果在暗光情况下使用P档，自动跳出的闪光灯可能会因为照射不到远处而导致远景过暗的情况，所以P档适合光线充足且摄距不远的情况下使用</li>
</ul>
]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title>Composition Rules</title>
    <url>/2020/Composition-Rules/</url>
    <content><![CDATA[<h4 id="构图目的"><a href="#构图目的" class="headerlink" title="构图目的"></a>构图目的</h4><ul>
<li><p>突出被摄主体: 观者的视线能被吸引到被摄主体上</p>
</li>
<li><p>画面简洁: 只保留必要元素，消除或减少分散观者注意力到元素</p>
</li>
</ul>
<h4 id="如何构图"><a href="#如何构图" class="headerlink" title="如何构图"></a>如何构图</h4><ul>
<li><strong>主体要突出</strong><ul>
<li>调整虚实</li>
<li>控制明暗</li>
<li>改变焦距</li>
</ul>
</li>
<li><strong>陪体有力衬托主体</strong><ul>
<li>渲染气氛</li>
<li>增加画面趣味性</li>
<li>与主题形成内容呼应</li>
<li>平衡画面，增加空间感</li>
</ul>
</li>
<li><strong>背景衬托</strong><ul>
<li>好的背景要简洁</li>
<li>好的背景可以交代环境信息，并与主体形成呼应</li>
</ul>
</li>
</ul>
<h4 id="构图方法"><a href="#构图方法" class="headerlink" title="构图方法"></a>构图方法</h4><ul>
<li><strong>三分构图法</strong><ul>
<li>横向(风光照片)<ul>
<li>天际线在画面上下方1/3</li>
</ul>
</li>
<li>竖向(人像照片)<ul>
<li>主体人物在左右侧1/3</li>
</ul>
</li>
</ul>
</li>
<li><strong>九宫格构图法</strong><ul>
<li>将需要表现的主体放在九宫格的4个交叉点上</li>
</ul>
</li>
<li><strong>线条构图法</strong><ul>
<li>曲线: 不呆板，延伸画面空间感<ul>
<li>小路 / 河流 / 女性身体曲线</li>
</ul>
</li>
<li>斜线: 力量与方向感，增强主体的气势和视觉冲击力<ul>
<li>运动体 / 人物身体线条</li>
</ul>
</li>
<li>汇聚线: 中心点<ul>
<li>视线 / 运动趋势</li>
</ul>
</li>
</ul>
</li>
<li><strong>形状构图法</strong><ul>
<li>三角形构图: 稳定性</li>
<li>弧线形构图: 柔美、生动</li>
<li>框架构图<ul>
<li>风光摄影: 修饰主题 / 浓缩远景 / 汇聚视线</li>
<li>人像摄影: 强化画面的空间感 / 丰富画面故事感</li>
<li>屋檐 / 门框 / 桥洞 / 树枝</li>
</ul>
</li>
</ul>
</li>
<li><strong>对称构图</strong><ul>
<li>将画面分割成对称的两部分: 平衡 / 稳定 / 相互呼应</li>
<li>庄重而平稳的建筑物 / 正面人像 / 倒影的场合</li>
<li>风光摄影: 水面的倒影</li>
<li>人像摄影: 一左一右对称</li>
</ul>
</li>
<li><strong>对比构图</strong><ul>
<li>突出主体，让照片更加戏剧化、富有艺术感染力</li>
<li>视觉反差强烈的色彩对比<ul>
<li>冷(蓝 / 绿): 使人后退</li>
<li>暖(黄 / 红): 使人前进</li>
</ul>
</li>
<li>影调丰富的明暗对比<ul>
<li>将视觉中心汇聚到画面中的明亮处，并增加空间感</li>
</ul>
</li>
<li>给人想象空间的虚实对比<ul>
<li>以虚映实，突出清晰的主体，并延伸空间感，创造画面故事感</li>
</ul>
</li>
<li>夸张效果的大小对比<ul>
<li>丰富视觉表现力</li>
</ul>
</li>
<li>画面舒展的疏密对比<ul>
<li>厚实 / 密不透风: 沉重和压抑</li>
<li>稀疏 / 松散: 轻松的自然美感</li>
<li>疏而不散 / 密而不乱: 松弛有度的节奏感和韵律感</li>
</ul>
</li>
<li>动感强烈的动静对比<ul>
<li>容易引起观看者的强烈关注</li>
<li>快门速度快(&gt;1/2s): 动静结合</li>
<li>快门速度慢(&lt;1/20s): 人影飘忽</li>
</ul>
</li>
</ul>
</li>
<li><strong>留白让照片更有想象空间</strong><ul>
<li>单一色调烘托画面意境，延伸画面空间</li>
<li>天空 / 水面 / 浓雾 / 草原 / 人物视线</li>
</ul>
</li>
<li><strong>善用前景营造唯美梦幻意境</strong><ul>
<li>虚化前景，实现梦幻的画面意境</li>
<li>树叶 / 花朵: 安排在画面的边缘</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB Installation on Mac OS</title>
    <url>/2021/GDB-Installation-on-Mac-OS/</url>
    <content><![CDATA[<h4 id="Step-1-Install-gdb"><a href="#Step-1-Install-gdb" class="headerlink" title="Step 1. Install gdb"></a>Step 1. Install gdb</h4><ol>
<li><p>To install gdb by the following command on terminal:</p>
<p><code>brew install gdb</code></p>
</li>
<li><p>We can confirm whether gdb is installed successfully by running:</p>
<p><code>gdb --version</code></p>
<p>On my Mac, we can see:</p>
<img src="/images/gdbversion.png" alt="gdbversion" style="zoom:67%;" />
</li>
<li><p>However, we will get the information as follows while try to run a program:</p>
<p><code>Unable to find Mach task port for process-id XXXXX: (os/kern) failure (0x5).</code><br><code>(please check gdb is codesigned - see taskgated(8))</code></p>
</li>
</ol>
<h4 id="Step-2-Create-a-Certificate"><a href="#Step-2-Create-a-Certificate" class="headerlink" title="Step 2. Create a Certificate"></a>Step 2. Create a Certificate</h4><ol>
<li><p>Open Launchpad -&gt; Other -&gt;  Keychain Access</p>
</li>
<li><p>In its menu, open Keychain Access -&gt; Certificate Assistant -&gt; Create a certificate</p>
</li>
<li><p>While creating, we set Identity type to Self Signed Root, Certificate type to Code Signing, and check “let me override defaults”. </p>
<img src="/images/creategdbcert.png" alt="creategdbcert" style="zoom:67%;" />
</li>
<li><p>We just continue until we get a page which prompts us for “specify a location”, and select Keychain location to System. Then, create a certificate and close assistant.</p>
<p>Noting: If we get an error as follows, we need to repeat the whole Step 2, but set Keychain location to Login in 4.</p>
<p><code>Unknown Error = -2,147,414,007</code></p>
</li>
<li><p>Find the certificate we just created, and double click it. Then, modify Trust, set Code Signing to Always Trust.</p>
<img src="/images/gdbtrust.png" alt="gdbtrust" style="zoom:67%;" />
</li>
<li><p>Restart taskgated in terminal by running:</p>
<p><code>sudo killall taskgated</code></p>
</li>
<li><p>Create a file called gdb-entitlement.xml which allows OS to trust gdb for debugging:</p>
<p><code>vim  gdb-entitlement.xml</code></p>
<p>which includes:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="meta-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.cs.allow-jit<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.cs.allow-unsigned-executable-memory<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.cs.allow-dyld-environment-variables<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.cs.disable-library-validation<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.cs.disable-executable-page-protection<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.cs.debugger<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.get-task-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Run codesign on terminal: </p>
<p><code>codesign --entitlements gdb-entitlement.xml -fs gdb-cert /usr/local/bin/gdb</code></p>
<p>And, we will ask for inputting the root password.</p>
</li>
<li><p>Finally, reboot!</p>
</li>
</ol>
<h4 id="Step-3-Runing-gdb"><a href="#Step-3-Runing-gdb" class="headerlink" title="Step 3. Runing gdb"></a>Step 3. Runing gdb</h4><ol>
<li><p>Create HelloWorld.c using C:</p>
<p><code>#include &lt;stdio.h&gt;</code></p>
<p><code>int main()&#123;</code></p>
<pre><code>`printf(&quot;Hello World!\n&quot;);`
`return 0;`</code></pre>
<p><code>&#125;</code></p>
</li>
<li><p>Compile it with -g option:</p>
<p><code>gcc HelloWorld.c -g -o HelloWorld</code></p>
</li>
<li><p>Run gdb to debug this program. Successfully!!!</p>
<img src="/images/gdbdebug.png" alt="gdbdebug" style="zoom:67%;" />

<p>Noting, if we find the following information, and the debugger is stopped:</p>
<p><code>[New Thread 0x1a03 of process 3822]</code></p>
<p>We need to type the following into the terminal, and restart a debugger:</p>
<p><code>echo &quot;set startup-with-shell off&quot; &gt;&gt; ~/.gdbinit</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>C Language</tag>
        <tag>Linux</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY a VPN With SSR</title>
    <url>/2020/DIY-a-VPN-With-SSR/</url>
    <content><![CDATA[<p>Website: <a href="https://www.vultr.com/">https://www.vultr.com/</a></p>
<p>Software: Shadowsocks + Ubuntu OS</p>
<h4 id="Step-1-服务器端安装Shadowsocks"><a href="#Step-1-服务器端安装Shadowsocks" class="headerlink" title="Step 1. 服务器端安装Shadowsocks"></a>Step 1. 服务器端安装Shadowsocks</h4><p>服务端版本：Shadowsocks-Python， ShadowsocksR， Shadowsocks-Go， Shadowsocks-libev（四选一）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x shadowsocks-all.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span></span><br></pre></td></tr></table></figure>


<p>卸载方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./shadowsocks-all.sh uninstall</span></span><br></pre></td></tr></table></figure>


<h4 id="Step-2-各版本的启动脚本及配置文件名"><a href="#Step-2-各版本的启动脚本及配置文件名" class="headerlink" title="Step 2. 各版本的启动脚本及配置文件名"></a>Step 2. 各版本的启动脚本及配置文件名</h4><p>启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。</p>
<p>Shadowsocks-Python 版：</p>
<p>/etc/init.d/shadowsocks-python start | stop | restart | status</p>
<p>ShadowsocksR 版：</p>
<p>/etc/init.d/shadowsocks-r start | stop | restart | status</p>
<p>Shadowsocks-Go 版：</p>
<p>/etc/init.d/shadowsocks-go start | stop | restart | status</p>
<p>Shadowsocks-libev 版：</p>
<p>/etc/init.d/shadowsocks-libev start | stop | restart | status</p>
<p>各版本默认配置文件</p>
<p>Shadowsocks-Python 版：</p>
<p>/etc/shadowsocks-python/config.json</p>
<p>ShadowsocksR 版：</p>
<p>/etc/shadowsocks-r/config.json</p>
<p>Shadowsocks-Go 版：</p>
<p>/etc/shadowsocks-go/config.json</p>
<p>Shadowsocks-libev 版：</p>
<p>/etc/shadowsocks-libev/config.json</p>
<h4 id="Step-3-安装VPN加速器"><a href="#Step-3-安装VPN加速器" class="headerlink" title="Step 3. 安装VPN加速器"></a>Step 3. 安装VPN加速器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget <span class="string">&quot;https://github.com/chiakge/Linux-NetSpeed/raw/master/tcp.sh&quot;</span> &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</span></span><br></pre></td></tr></table></figure>


<p>安装 BBR</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span></span><br></pre></td></tr></table></figure>
<p>获取读写权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x bbr.sh</span></span><br></pre></td></tr></table></figure>
<p>启动BBR安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bbr.sh</span></span><br></pre></td></tr></table></figure>


<h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A?"></a>Q &amp; A?</h4><p>Q: 解决Host key verification failed</p>
<p>A: ssh-keygen -R 你要访问的IP地址</p>
]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction to Camera Lens</title>
    <url>/2020/Introduction-to-Camera-Lens/</url>
    <content><![CDATA[<h4 id="相机镜头介绍"><a href="#相机镜头介绍" class="headerlink" title="相机镜头介绍"></a>相机镜头介绍</h4><ul>
<li><p><strong>装卸方法:</strong> 将机身镜头卡口朝下，迅速更换镜头</p>
<ul>
<li>取下机身盖和镜头的后盖，准备安装镜头</li>
<li>将镜头的红色标志与机身的红色标志对齐，缓慢、平稳地将镜头安装与机身</li>
<li>镜身插入机身后，沿顺时针方向(面向相机正面)旋转镜头，听到“咔”的声音，说明安装的镜头已锁定</li>
</ul>
</li>
</ul>
<h4 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h4><ul>
<li><p><strong>口径:</strong> 相机镜头前端的螺纹口径</p>
</li>
<li><p><strong>光圈:</strong> 控制光线进入镜头的装置，光圈大小以F值表示</p>
<ul>
<li>恒定光圈: F4G指每一个焦段都可以使用最大为F4的光圈值来拍摄</li>
<li>浮动光圈: F4-5.6指焦距变化时，最大光圈也在F4和F5.6之间进行变化</li>
<li>通常情况下，光圈越大越好，恒定光圈比浮动光圈好</li>
</ul>
</li>
<li><p><strong>焦距:</strong> 定焦镜头 / 变焦镜头</p>
<ul>
<li><p><strong>最近对焦距离</strong></p>
<ul>
<li>镜头可以对焦的最短距离，镜头无法在短于最小对焦距离的位置对焦</li>
<li>测量与拍摄对象间的距离是从相机机身上的焦平面标记开始而不是从相机前部开始</li>
</ul>
</li>
<li><p><strong>焦距不同带来画面视角的差异(相机位置不变)</strong></p>
<ul>
<li>焦距越长(200mm)，视角越窄，拍进画面的景物范围也越窄，被摄体成像就会越大</li>
<li>焦距越短(100mm)，视角越广，拍进画面的景物范围也越广，被摄体成像就会越小</li>
</ul>
<img src="/images/ViewFromFocus.png" alt="ViewFromFocus" style="zoom:67%;" />
</li>
<li><p><strong>焦距不同带来画面纵深感的差异(被摄体大小不变)</strong></p>
<ul>
<li>焦距越长(200mm)，拍进画面的范围越窄，视觉上被摄体离背景更近，纵深感更弱</li>
<li>焦距越短(100mm)，拍进画面的范围越宽，视觉上被摄体离背景更远，纵深感更强</li>
</ul>
<img src="/images/LayerFromFocus.png" alt="LayerFromFocus" style="zoom:67%;" />
</li>
</ul>
</li>
<li><p><strong>防抖:</strong> 通过一组矫正镜组对因抖动产生的光路偏移进行矫正，防止成像模糊的问题</p>
</li>
</ul>
<h4 id="镜头选择"><a href="#镜头选择" class="headerlink" title="镜头选择"></a>镜头选择</h4><ul>
<li>变焦镜头由于要控制镜头的体积和重量，因此在画质上有所妥协，成像效果不及同规格的定焦镜头</li>
<li>定焦镜头具备更大的光圈，非常适合拍摄背景虚化的人像照片和弱光环境下的星空题材</li>
<li><strong>广角镜头(14<del>20mm 或 24</del>38mm):</strong><ul>
<li>视野宽阔，比人眼看到的景物范围大得多，同时具备大景深的特点，可以将远景和近景都拍摄得很清楚。广角镜头能强调画面的透视效果，并且善于夸张前景和表象景物的远近感</li>
</ul>
</li>
<li><strong>人物纪实(35mm):</strong><ul>
<li>透视变形不严重的小广角镜头</li>
</ul>
</li>
<li><strong>标准镜头(40~55mm):</strong><ul>
<li>接近人眼看到的景象，其透视关系接近于人眼所感觉到的透视关系，所以能够逼真地再现被摄物体的真实特征</li>
</ul>
</li>
<li><strong>中焦镜头(85mm 或 105mm 或 135mm):</strong><ul>
<li>变形效果小，配合大光圈可以获得极佳的背景虚化效果</li>
</ul>
</li>
<li><strong>长变焦镜头(70~200mm):</strong><ul>
<li>具备望远功能，可以压缩画面的空间感</li>
</ul>
</li>
<li><strong>微距镜头:</strong><ul>
<li>能把主体的细节纤毫毕现地表现出来，主要用于拍摄十分微小的物体</li>
</ul>
</li>
<li><strong>鱼眼镜头:</strong><ul>
<li>180度超大广角，会导致桶形畸变</li>
</ul>
</li>
<li><strong>移轴镜头:</strong><ul>
<li>可实现倾角与偏移功能的特殊镜头，其主要目的是调整透视变形。通过使用倾角与偏移功能像各种角度和位置转动镜头，可以移动合焦面或对被摄体的形状进行补偿。主要用于建筑摄影和广告摄影</li>
</ul>
</li>
<li><strong>UV镜:</strong><ul>
<li>紫外线滤光镜，主要作用是保护镜头，同时能过滤紫外线(有助于提高成像清晰度和色彩效果)</li>
</ul>
</li>
<li><strong>偏光镜PL:</strong><ul>
<li>偏振镜，它利用偏振光的特性，把非金属物体、水面等被摄物体的反光进行过滤消除，使成像色彩更加鲜艳。PL分为圆偏光镜(CPL)和线性偏光镜(LPL)</li>
</ul>
</li>
<li><strong>中灰滤镜:</strong><ul>
<li>ND镜，中灰密度镜，仅一块灰色纯透明的光学玻璃，其目的是减少进入镜头的通光量，从而有效降低曝光量</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title>OverlayFS -- A Container File System</title>
    <url>/2021/OverlayFS-A-Container-File-System/</url>
    <content><![CDATA[<h4 id="1-基本概念和特征"><a href="#1-基本概念和特征" class="headerlink" title="1. 基本概念和特征"></a>1. 基本概念和特征</h4><p>Docker容器最常用的文件系统是AUFS, 但随着Linux Kernel 3.18把Overlay纳入其中后，Overlay文件系统的地位就变得尤为重要。目前，Docker默认的存储文件系统是Overlay，相比于AUFS，其速度更快，实现也更为简单。</p>
<p>Overlay文件系统将不同的目录(底层目录和高层目录)划分为不同的层次，并通过联合挂载过程将数个高、底层目录合并成一个统一的目录，即统一合并视图层。如下图所示，在Docker与Overlay文件系统的分层图中，只读镜像层是底层目录，读写容器层是高层目录，而容器运行实际的应用层是统一合并视图层。</p>
<img src="/images/overlayarch.png" alt="overlayarch" style="zoom:67%;" />

<p>在Overlay文件系统中，用户只能看到存在于统一合并视图层中的目录和文件，但这些目录和文件既可能来自于高层目录，也可能来自于底层目录。因此，当用户查看统一合并视图层的目录或文件时，用户会感觉到上下层同名目录合并和上下层同名文件覆盖：</p>
<ol>
<li><p><strong>上下层同名目录合并：</strong>如果某个目录并不是仅来自单独的一层(仅高层目录或底层目录)，它会逐级遍历(从高层目录到底层目录，再到更低的底层目录)扫描所有层中的同名目录，然后将同名目录中的内容合并后，返回给用户唯一一个包含全部内容的同名目录。</p>
</li>
<li><p><strong>上下层同名文件覆盖：</strong>如果在遍历扫描过程中发现同名文件，Overlay文件系统会优先向用户呈现较高层中的文件，即忽略来自底层目录的文件而只显示来自高层目录的文件，或者忽略来自较低底层目录的文件而显示来自更高底层目录的文件。</p>
</li>
</ol>
<p>值得注意的是，高层目录和底层目录中文件的存储和组织方式是基于宿主机文件系统，即Ext4文件系统，而不是基于Overlay文件系统。Overlay文件系统提供的功能仅是将数个目录层联合挂载到统一合并视图层，并提供相应的文件访问接口。</p>
<h4 id="2-基本文件操作"><a href="#2-基本文件操作" class="headerlink" title="2. 基本文件操作"></a>2. 基本文件操作</h4><p>在Overlay文件系统中，用户视角只能看到统一合并视图层的内容。因此，用户相应的Overlay基本文件操作(如文件创建、删除、读取、写入等)也都起始于统一合并视图层。然而，统一合并视图层仅提供实际文件的视图，并不存储和组织实际的文件(存储在属于Ext4文件系统的高层目录和底层目录中)。因此，当统一合并视图层的基本文件操作发生时，Overlay文件系统通过自身文件系统定义的函数接口找到操作对象在高层目录和底层目录对应的实际文件，然后将控制权转移给Ext4文件系统，最后通过VFS进一步调用操作系统定义的文件操作。而这个跨层文件的转换过程被称为文件重定向(file redirection)。</p>
<p>Overlay文件系统的基本文件操作包括<strong>文件读取、文件写入、文件创建</strong>和<strong>文件删除</strong>。但是根据不同的操作类型和实际文件所在的层次，Overlay文件系统会分别采取不同的处理策略：</p>
<h5 id="1-文件读取操作"><a href="#1-文件读取操作" class="headerlink" title="1) 文件读取操作"></a>1) 文件读取操作</h5><p><strong>场景1.</strong> 文件和目录只存在于底层目录，却不存在于高层目录：Overlay文件系统通过视图层的文件和目录的目录项，使用文件重定向找到其在底层目录中对应的实际目录项与索引节点，接着将操作的控制权转交给VFS，并由VFS进一步执行操作系统已定义好的读取操作；</p>
<p><strong>场景2.</strong> 文件和目录只存在于高层目录，却不存在于底层目录：与场景1的过程基本相同，唯有通过文件重定向找到在高层目录中对应的实际目录项(real_dentry)与索引节点，再将控制权转交给VFS；</p>
<p><strong>场景3.</strong> 文件和目录同时存在于高层目录和底层目录：由于Overlay文件系统的视图层会用高层目录中的文件覆盖底层目录中的文件，所以读取过程和场景2相同。</p>
<h5 id="2-文件写入操作"><a href="#2-文件写入操作" class="headerlink" title="2) 文件写入操作"></a>2) 文件写入操作</h5><p><strong>场景1.</strong> 文件和目录是首次写入，仅存在于底层目录，且不存在于高层目录中：Overlay文件系统通过文件重定向找到底层目录中的实际文件，再执行写时复制(Copy-on-Write, CoW)，将对象从底层目录拷贝到高层目录；然后，将复制后的目录和文件的目录项和控制权转交给VFS；接着，VFS进一步执行宿主机文件系统已定义的文件写入操作，读取拷贝的文件和目录并修改，再将修改后的结果保存在高层目录。值得注意的是，Overlay属于文件级别的文件系统：即使文件只有很小一部分的修改，也会触发写时复制；</p>
<p><strong>场景2.</strong> 文件和目录是首次写入，但存在于高层目录：与场景1处理基本相同，但不会发生写时复制(Copy-on-Write)。Overlay文件系统仅通过文件重定向将视图层对象的目录项转换为高层目录中对应的目录项，并将其和它的控制权转交给VFS；</p>
<p><strong>场景3.</strong> 文件和目录是非首次写入，则一定存在于高层目录：解决方案与场景2完全相同。</p>
<h5 id="3-文件创建操作"><a href="#3-文件创建操作" class="headerlink" title="3) 文件创建操作"></a>3) 文件创建操作</h5><p><strong>场景1.</strong> 创建在底层目录和高层目录中都不存在的文件或目录：直接在高层目录中创建新的文件或目录；</p>
<p><strong>场景2.</strong> 创建在底层目录已经存在，且在高层目录有whiteout文件的同名文件：Overlay文件系统会删除高层目录中的whiteout文件，并用新创建的文件替换它。通过这种方式，用户就能在统一合并视图层中看到高层目录中创建的新文件；</p>
<p><strong>场景3.</strong> 创建在底层目录已经存在，且在高层目录有whiteout文件的同名目录：由于同名目录上下层合并，所以若这时仅仅在高层目录中新建一个目录，则底层目录中对应目录中的内容也会暴露。因此，Overlay文件系统引入opaque属性，在读取上下层同名目录的目录项时，对高层目录中具有opaque属性的目录，Overlay文件系统会忽略在底层目录中同名目录下的所有目录项，以保证在用户视图中该新建目录仅是一个空目录。</p>
<h5 id="4-文件删除操作"><a href="#4-文件删除操作" class="headerlink" title="4) 文件删除操作"></a>4) 文件删除操作</h5><p><strong>场景1.</strong> 删除的文件或目录来自高层目录，且在底层目录中没有同名对象：由于高层目录中的对象是可读可写的，因此所有的文件操作都可以直接作用在高层目录。因此，Overlay文件系统会直接删除高层目录中对应的文件或目录；</p>
<p><strong>创建2.</strong> 删除的文件或目录来自底层目录，且在高层目录不存在覆盖文件：由于底层对象是只读的，因此Overlay文件系统不能直接删除底层目录中的文件或目录。Overlay文件系统必须既让用户认为目标已删除，却又不执行真正的删除操作；<br>为了达到这种效果，Overlay文件系统会在高层目录中删除文件的同时，创建同名的whiteout文件，用于屏蔽底层目录中的文件或目录。因此，当用户在视图层查看文件或目录时，由于whiteout文件的存在，底层目录中对应的文件或目录对用户不可见，就像被删除一样。但实际对象依旧存在于底层目录中；</p>
<p><strong>场景3.</strong> 删除的文件是高层目录的文件覆盖底层目录的文件，或删除的目录是上下层合并的目录：该场景的属于场景1和场景2的合并，Overlay文件系统既要删除高层目录中的文件和目录，也会在高层目录中创建同名的whiteout文件，从而保证高层目录的文件或目录被删除后而不至于底层对象被暴露出来。</p>
<h4 id="3-原子性保证件"><a href="#3-原子性保证件" class="headerlink" title="3. 原子性保证件"></a>3. 原子性保证件</h4><p>文件系统的原子性指所有的文件操作要么全部完成，要么全部不完成，不可能停滞在中间某个环节，否则有可能会破坏文件数据或元数据的原子性。而Overlay文件系统必须要保证文件创建、文件删除和写时复制等过程的原子性：</p>
<p><strong>场景1.</strong> 删除高层目录中的文件并创建whiteout文件：Overlay文件系统要保证高层目录中的删除目标文件和创建whiteout文件两个操作同时发生的原子性，不存在删除文件后whiteout文件还未创建的状态；</p>
<p><strong>场景2.</strong> 删除上下层合并目录：Overlay文件系统必须要保证被删除的目录为空，即目录和文件同时被删除的原子性，不存在部分数据删除，部分数据保留的状态；</p>
<p><strong>场景3.</strong> 新创建与whiteout同名的文件和目录：Overlay文件系统要保证删除whiteout文件和创建新文件两个操作同时发生的原子性，不存在删除whiteout文件后新文件还未创建的状态；</p>
<p><strong>场景4.</strong> 底层文件的写时复制：Overlay文件系统要保证文件拷贝的原子性，不存在只拷贝部分数据的状态。</p>
<img src="/images/overlayatom.png" alt="overlayatom" style="zoom:67%;" />

<p>为了保证自身文件操作的原子性，Overlay文件系统使用工作目录(workdir)和重命名操作(rename)。如上图所示，以删除同时存在于高 / 底层目录的文件为例，其原子性保证的工作原理主要分为三个步骤：</p>
<p><strong>①创建：</strong>在工作目录中创建用于同名whiteout文件(若是写时复制过程，则将目标文件从底层目录复制到工作目录)；</p>
<p><strong>②交换：</strong>使用重命名操作将被删除的目标文件与工作目录中的whiteout文件进行交换 (若是写诗赋值过程，则通过重命名操作移动拷贝文件)来实现文件的原子性替换，而其原子性由宿主机文件系统已定义的重命名操作来保证；</p>
<p><strong>③删除：</strong>将工作目录中的目标文件删除(若是写时复制，则没有这个步骤)。</p>
<p>在上述的每个步骤中，即使系统出现异常或崩溃，磁盘也只会在工作目录中多出未被及时删除的目标文件、whiteout文件或拷贝不完全的文件；当操作系统恢复正常且再次挂载Overlay文件系统时，工作目录中的文件会被继续清除。通过这种方式，Overlay文件系统能够保证文件系统中所有基本文件操作的原子性。</p>
]]></content>
      <categories>
        <category>Container</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
        <tag>Overlay</tag>
        <tag>File System</tag>
      </tags>
  </entry>
  <entry>
    <title>Parameters of Camera</title>
    <url>/2020/Parameters-of-Camera/</url>
    <content><![CDATA[<h4 id="Step-1-设置存储格式和白平衡"><a href="#Step-1-设置存储格式和白平衡" class="headerlink" title="Step 1. 设置存储格式和白平衡"></a>Step 1. 设置存储格式和白平衡</h4><ul>
<li><p><strong>存储格式</strong></p>
<ul>
<li>RAW格式: 未经任何处理和压缩的无损照片格式</li>
<li>JPEG格式: 经过相机优化处理、被压缩的有损照片格式</li>
</ul>
</li>
<li><p><strong>色温</strong></p>
<ul>
<li>纯黑体在该温度下所发射的光颜色与某个光源所发射的光颜色看起来相同<ul>
<li>3000K⬇️            带红的白色，热烈温暖</li>
<li>3000K~5000K        白色，清爽</li>
<li>5000K⬆️            带蓝的白色，冰冷清凉</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>白平衡</strong></p>
<ul>
<li>数码相机对拍摄环境中由于光线色温不同而造成的偏色进行纠正<ul>
<li>自动        3500K~8000K</li>
<li>晴天        5200K</li>
<li>阴天        6000K</li>
<li>背阴        8000K</li>
<li>白炽灯        3000K</li>
<li>荧光灯        2700K~7200K</li>
<li>闪光灯        5400K</li>
<li>手动预设    混合光照环境</li>
<li>选择色温    2500K~10000K</li>
</ul>
</li>
<li>RAW模式不用担心白平衡设置错误</li>
<li>JPEG模式选择自动白平衡更保险</li>
</ul>
</li>
</ul>
<h4 id="Step-2-选择曝光模式"><a href="#Step-2-选择曝光模式" class="headerlink" title="Step 2. 选择曝光模式"></a>Step 2. 选择曝光模式</h4><ul>
<li><p><strong>光圈</strong></p>
<ul>
<li>光圈的F值 = 镜头的焦距 / 镜头光圈的直径<ul>
<li>相邻两档光圈的曝光量是两倍的关系<ul>
<li>F2.8光圈的曝光量是F4曝光量的两倍</li>
</ul>
</li>
</ul>
</li>
<li>相同条件下，<ul>
<li>光圈越大，曝光量越大，照片越明亮</li>
<li>光圈越小，曝光量越小，照片越暗淡</li>
</ul>
</li>
<li>在焦距、物距和背景距离不变的情况下，<ul>
<li>光圈越大，景深越小，背景虚化效果越强</li>
<li>光圈越小，景深越大，背景虚化效果越弱</li>
</ul>
</li>
<li>在光圈、物距和背景距离不变的情况下，<ul>
<li>焦距越长，景深越小，背景虚化效果越强</li>
<li>焦距越短，景深越大，背景虚化效果越弱</li>
</ul>
</li>
<li>在光圈、焦距和背景距离不变的情况下，<ul>
<li>物距越近，景深越小，背景虚化效果越强</li>
<li>物距越远，景深越大，背景虚化效果越弱</li>
</ul>
</li>
<li>在光圈、焦距和物距不变的情况下，<ul>
<li>背景距离拍摄主体越远，景深越小，背景虚化效果越强</li>
<li>背景距离拍摄主体越近，景深越大，背景虚化效果越弱</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>快门速度</strong></p>
<ul>
<li>快门是控制光线进入相机时间长短的装置</li>
<li>相同两档快门速度的曝光量之间是两倍的关系<ul>
<li>1/4s快门速度的曝光量是1/8快门速度的曝光量的两倍</li>
</ul>
</li>
<li>在光圈和感光度相同时，<ul>
<li>快门速度越慢，曝光量越大，照片越明亮</li>
<li>快门速度越快，曝光量越小，照片越暗淡</li>
</ul>
</li>
<li>安全快门<ul>
<li>手持拍摄时，保证拍摄到的照片不发虚所需要设置的最低快门速度</li>
<li>安全快门速度 = 焦距的倒数</li>
<li>尼康APS-C半画幅相机</li>
<li>安全快门速度 = 1 / (焦距 * 1.5)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>感光度</strong></p>
<ul>
<li>相邻两档感光度的曝光量之间是两倍的关系<ul>
<li>感光度200的曝光量是感光度100的曝光量的两倍</li>
</ul>
</li>
<li>相同条件下，<ul>
<li>感光度越高，曝光量越大，照片越明亮</li>
<li>感光度越低，曝光量越小，照片越暗淡</li>
</ul>
</li>
<li>ISO感光度不宜过高<ul>
<li>低感光度的照片噪点很少，画质细腻</li>
<li>高感光度的照片噪点较多，画质粗糙</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>曝光组合(明暗控制)</strong></p>
<ul>
<li>提亮照片<ul>
<li>开大光圈</li>
<li>降低快门速度</li>
<li>提高感光度</li>
</ul>
</li>
<li>压暗照片<ul>
<li>缩小光圈</li>
<li>提高快门速度</li>
<li>降低感光度</li>
</ul>
</li>
<li>相同的曝光效果<ul>
<li>感光度不变<ul>
<li>光圈增加一档，快门速度下降一档</li>
<li>光圈降低一档，快门速度增加一档</li>
</ul>
</li>
<li>光圈不变<ul>
<li>感光度增加一档，快门速度下降一档</li>
<li>感光度降低一档，快门速度增加一档</li>
</ul>
</li>
<li>快门速度不变<ul>
<li>感光度增加一档，光圈下降一档</li>
<li>感光度降低一档，光圈增加一档</li>
</ul>
</li>
</ul>
</li>
<li>曝光模式<ul>
<li>光圈优先A<ul>
<li>风光摄影: 小光圈减少虚化</li>
<li>人物摄影: 大光圈突出人物、虚化背景</li>
<li>弱光环境: 大光圈提高快门速度</li>
</ul>
</li>
<li>快门优先S<ul>
<li>高速快门: 凝固物体运动的瞬间</li>
<li>慢速快门: 记录物体的运动轨迹</li>
</ul>
</li>
<li>手动模式M<ul>
<li>光线稳定</li>
<li>弱光环境</li>
<li>闪光灯环境</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Step-3-设置曝光组合"><a href="#Step-3-设置曝光组合" class="headerlink" title="Step 3. 设置曝光组合"></a>Step 3. 设置曝光组合</h4><ul>
<li>室外晴天时的曝光组合设置<ul>
<li>小光圈 + 低感光度<ul>
<li>保证细腻画质和较大的景深效果</li>
</ul>
</li>
<li>大光圈 + 低感光度<ul>
<li>保证细腻画质和景深虚化的小景深效果</li>
</ul>
</li>
</ul>
</li>
<li>室外阴天或傍晚时的曝光组合设置<ul>
<li>大光圈 + 高感光度 <ul>
<li>保证快门速度高于安全快门</li>
</ul>
</li>
</ul>
</li>
<li>室内弱光环境的曝光组合设置<ul>
<li>大光圈 + 高感光度<ul>
<li>保证不拍虚的快门速度</li>
</ul>
</li>
</ul>
</li>
<li>室内窗户光的曝光组合模式<ul>
<li>大 / 中 / 小光圈 + 低 / 高感光度<ul>
<li>保证不拍虚的快门速度</li>
</ul>
</li>
</ul>
</li>
<li>应对多数场景的曝光组合设置<ul>
<li>小光圈 + 低感光度<ul>
<li>更大的景深效果和更细腻的画质</li>
</ul>
</li>
</ul>
</li>
<li>例外场景的曝光组合设置<ul>
<li>弱光环境: 小光圈 + 高感光度</li>
<li>星空题材: 大光圈 + 高感光度</li>
</ul>
</li>
<li>凝固物体运动瞬间的曝光组合设置<ul>
<li>浪花: 1/500s</li>
<li>动物: 1/2000s</li>
</ul>
</li>
<li>表现物体运动轨迹的曝光组合设置<ul>
<li>絮状流水: 1/2s</li>
<li>飞桥: 1/320s</li>
<li>飞驰的汽车: 1/60 ~ 1/30s</li>
<li>烟花: 小光圈 + 低感光度 + 5 ~ 20s</li>
</ul>
</li>
</ul>
<h4 id="Step-4-选择测光模式"><a href="#Step-4-选择测光模式" class="headerlink" title="Step 4. 选择测光模式"></a>Step 4. 选择测光模式</h4><ul>
<li>区域平均测光<ul>
<li>着重于焦点所对应的区域进行测光，同时对其他区域进行大体平均测光的智能测光模式</li>
</ul>
</li>
<li>中央重点测光<ul>
<li>着重于中央区域进行测光的测光模式</li>
</ul>
</li>
<li>点测光<ul>
<li>对取景范围中很小的一部分特定区域测光，而不管其他区域的测光模式</li>
</ul>
</li>
<li>测光步骤<ul>
<li>根据不同的场景选择不同的测光模式</li>
<li>选择测光点的位置</li>
<li>曝光锁定</li>
</ul>
</li>
</ul>
<h4 id="Step-5-选择对焦模式"><a href="#Step-5-选择对焦模式" class="headerlink" title="Step 5. 选择对焦模式"></a>Step 5. 选择对焦模式</h4><ul>
<li><strong>自动对焦</strong><ul>
<li>单次自动对焦模式(AF-S)<ul>
<li>每半按一次快门就会锁定对焦</li>
<li>拍摄静止物体(风景、人像、静物、花卉)</li>
</ul>
</li>
<li>连续自动对焦模式(AF-C)<ul>
<li>半按快门期间，若被摄体移动，相机会再次对焦</li>
<li>拍摄有连续运动轨迹的物体(赛车、运动员、走秀、飞鸟)</li>
</ul>
</li>
<li>与单点自动对焦组合<ul>
<li>只选定单一的对焦点对被摄体对焦</li>
</ul>
</li>
<li>与区域自动对焦组合<ul>
<li>选定单一的对焦区域对被摄体对焦</li>
</ul>
</li>
<li>自动切换对焦模式(AF-I)<ul>
<li>根据被摄体是否移动来选择 AF-S / AF-C</li>
<li>拍摄运动轨迹不规律的主题(足球、篮球、运动员)</li>
</ul>
</li>
<li>埋伏对焦<ul>
<li>先半按快门对焦，待运动物体经过该位置，按下快门完成拍摄</li>
<li>拍摄可预测运动物体的运动轨迹</li>
</ul>
</li>
</ul>
</li>
<li><strong>手动对焦</strong><ul>
<li>在对比度不够的场合</li>
<li>在弱光环境下</li>
<li>微距(景深范围浅)</li>
<li>隔着玻璃拍摄<ul>
<li>焦点锁定在玻璃上的污迹或倒影上</li>
</ul>
</li>
<li><strong>操作要领</strong><ul>
<li>在对焦时，在焦点附近来回拧动对焦环，缩小范围，然后确定焦点</li>
<li>使用三脚架时，可以打开实时取景，放大焦点，在用对焦环进行微调</li>
</ul>
</li>
</ul>
</li>
<li><strong>常见拍摄题材的对焦点选择</strong><ul>
<li>人像照片的对焦点选择<ul>
<li>人物面部: 前眼</li>
<li>人物半身、全身的肖像以及环境人像: 头部            风光照片的对焦点选择</li>
<li>无突出点: 对无穷远处对焦</li>
<li>有突出点: 对突出点对焦</li>
<li>最大限度的前后景深范围: 超焦距<ul>
<li>H = F^2 / (f * c) + F</li>
<li>H: 超焦距</li>
<li>F: 镜头焦距</li>
<li>f: 光圈值</li>
<li>c: 弥散圆直径<ul>
<li>全画幅相机的弥散圆直径: 0.032</li>
<li>半画幅相机的弥散圆直径: 0.019</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>合照照片的对焦点选择<ul>
<li>寻找关键人物作为焦点并进行追踪对焦，等待其余人达到和谐点时拍摄</li>
</ul>
</li>
<li>动物类照片的对焦点选择<ul>
<li>眼睛</li>
</ul>
</li>
<li>花卉照片的对焦点选择<ul>
<li>远距离: 花瓣</li>
<li>近距离: 花蕊</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    </p>
<h4 id="Step-6-设置曝光补偿，纠正曝光效果"><a href="#Step-6-设置曝光补偿，纠正曝光效果" class="headerlink" title="Step 6. 设置曝光补偿，纠正曝光效果"></a>Step 6. 设置曝光补偿，纠正曝光效果</h4><ul>
<li>曝光: 照片成像的明暗效果<ul>
<li>曝光不足: 欠曝</li>
<li>曝光过度: 过曝</li>
<li>准确的曝光: 整体亮度适中，明暗都有细节，色彩饱和、正常</li>
</ul>
</li>
<li><strong>查看曝光效果的方法</strong><ul>
<li>调整液晶屏亮度</li>
<li>设置高光预警</li>
<li>查看直方图<ul>
<li>左右两侧“不起墙”<ul>
<li>左侧起墙: 阴影区域欠曝</li>
<li>右侧起墙: 高光区域过曝</li>
<li>左右侧都无墙: 对比度低，照片发灰</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>曝光补偿</strong><ul>
<li>人为地改变光圈大小和快门速度，使照片更明亮或更暗<ul>
<li>光圈优先<ul>
<li>减少曝光补偿: 提高快门速度</li>
<li>增加曝光补偿: 降低快门速度</li>
</ul>
</li>
<li>快门优先<ul>
<li>减少曝光补偿: 减小光圈大小</li>
<li>增加曝光补偿: 增加光圈大小</li>
</ul>
</li>
</ul>
</li>
<li>提前设置曝光补偿<ul>
<li>白加黑减<ul>
<li>当画面中白色物体或亮部占比较多时，需要在自动曝光的基础上增加曝光<ul>
<li>雪地、大雾、大面积白色墙壁、人物的脸部</li>
</ul>
</li>
<li>当画面中黑色物体或暗部占比较多时，需要在自动曝光的基础上减少曝光<ul>
<li>日出日落、剪影效果</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title>Photography Skills</title>
    <url>/2020/Photography-Skills/</url>
    <content><![CDATA[<h4 id="Q1-如何拍近距离照片？"><a href="#Q1-如何拍近距离照片？" class="headerlink" title="Q1: 如何拍近距离照片？"></a>Q1: 如何拍近距离照片？</h4><p>AV档 + 最大光圈 + ISO自动 + 单点对焦</p>
<p>注：最近对焦距离 和 闪光灯开关</p>
<h4 id="Q2-如何抓拍运动物体？"><a href="#Q2-如何抓拍运动物体？" class="headerlink" title="Q2: 如何抓拍运动物体？"></a>Q2: 如何抓拍运动物体？</h4><p>TV档 / 调高快门速度 + AUTO自动感光度(ISO) + 自动对焦 + 高速连拍</p>
<h4 id="Q3-如何拍花卉？"><a href="#Q3-如何拍花卉？" class="headerlink" title="Q3: 如何拍花卉？"></a>Q3: 如何拍花卉？</h4><p>大光圈镜头 / 长焦镜头 (虚化好)</p>
<p>广角俯拍大场景</p>
<p>远距离低角度拍 Q1</p>
<p>特写 + 人工露珠 Q1</p>
<p>逆光低角度仰拍脉络：点测光对准比较亮的花瓣</p>
<p>正上方俯拍：花蕊 + 花瓣</p>
<h4 id="Q4-如何拍创意光绘？"><a href="#Q4-如何拍创意光绘？" class="headerlink" title="Q4: 如何拍创意光绘？"></a>Q4: 如何拍创意光绘？</h4><p>画面左右反向</p>
<p>手电筒 + 小皮筋 + 彩布 = 彩光手电筒</p>
<p>TV档(长快门时间) + 最低ISO + 手电筒对相机镜头</p>
<h4 id="Q5-汽车尾灯拉丝"><a href="#Q5-汽车尾灯拉丝" class="headerlink" title="Q5: 汽车尾灯拉丝"></a>Q5: 汽车尾灯拉丝</h4><p>选择车流较多，地势较高的天桥或街道</p>
<p>三脚架 + Tv档 + 5-20s快门 + ISO为100</p>
<p><strong>Reference</strong></p>
<p>​    <a href="https://www.bilibili.com/video/av26545377?p=1">https://www.bilibili.com/video/av26545377?p=1</a></p>
]]></content>
      <categories>
        <category>Photography</category>
      </categories>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title>This is xiaoli7</title>
    <url>/2020/This-is-xiaoli7/</url>
    <content><![CDATA[<h2 id="Education"><a href="#Education" class="headerlink" title="Education"></a>Education</h2><h3 id="University-of-California-Davis-2020-9-Present"><a href="#University-of-California-Davis-2020-9-Present" class="headerlink" title="University of California, Davis 2020.9 - Present"></a><strong>University of California, Davis</strong> <code>2020.9 - Present</code></h3><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Sacramento,</span> America</span><br></pre></td></tr></table></figure>
<ul>
<li>M.S. in Computer Science</li>
<li>Cumulative GPA: <strong>3.7+/4.0</strong></li>
</ul>
<h3 id="Huazhong-University-of-Science-and-Technology-2017-9-2020-6"><a href="#Huazhong-University-of-Science-and-Technology-2017-9-2020-6" class="headerlink" title="Huazhong University of Science and Technology 2017.9 - 2020.6"></a><strong>Huazhong University of Science and Technology</strong> <code>2017.9 - 2020.6</code></h3><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Wuhan,</span> China</span><br></pre></td></tr></table></figure>
<ul>
<li>M.S. in Computer System Architecture</li>
<li>Cumulative GPA: <strong>82.65/100.00</strong></li>
<li>Computer Science Departmental Honors</li>
</ul>
<h3 id="Hunan-University-2013-9-2017-6"><a href="#Hunan-University-2013-9-2017-6" class="headerlink" title="Hunan University 2013.9 - 2017.6"></a><strong>Hunan University</strong> <code>2013.9 - 2017.6</code></h3><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Changsha,</span> China</span><br></pre></td></tr></table></figure>
<ul>
<li>B.S. in Software Engineering</li>
<li>Cumulative GPA: <strong>3.62/4.50</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Windows GoLang</title>
    <url>/2021/Windows-GoLang/</url>
    <content><![CDATA[<h3 id="1-下载安装包，根据操作系统选择GoLang版本"><a href="#1-下载安装包，根据操作系统选择GoLang版本" class="headerlink" title="1. 下载安装包，根据操作系统选择GoLang版本"></a>1. 下载安装包，根据操作系统选择GoLang版本</h3><p>下载地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a></p>
<p><img src="/images/go/go-1.png"></p>
<h3 id="2-打开安装包，并根据提示安装GoLang"><a href="#2-打开安装包，并根据提示安装GoLang" class="headerlink" title="2. 打开安装包，并根据提示安装GoLang"></a>2. 打开安装包，并根据提示安装GoLang</h3><p>将安装路径设置为C:\Go\</p>
<p><img src="/images/go/go-2.png"></p>
<h3 id="3-打开cmd，查看GoLand是否安装成功"><a href="#3-打开cmd，查看GoLand是否安装成功" class="headerlink" title="3. 打开cmd，查看GoLand是否安装成功"></a>3. 打开cmd，查看GoLand是否安装成功</h3><p>win+R并输入cmd打开命令行界面，接着使用go version来查看GoLand的版本信息</p>
<p><img src="/images/go/go-3.png"></p>
<h3 id="4-创建mygo目录，并设置为GOPATH的系统变量"><a href="#4-创建mygo目录，并设置为GOPATH的系统变量" class="headerlink" title="4. 创建mygo目录，并设置为GOPATH的系统变量"></a>4. 创建mygo目录，并设置为GOPATH的系统变量</h3><p><img src="/images/go/go-4.png"></p>
]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes Installation</title>
    <url>/2021/Kubernetes-Installation/</url>
    <content><![CDATA[<h2 id="机器配置"><a href="#机器配置" class="headerlink" title="机器配置"></a>机器配置</h2><table>
<thead>
<tr>
<th>主机名</th>
<th>角色</th>
<th>IP</th>
<th>系统</th>
</tr>
</thead>
<tbody><tr>
<td>centos-istio-0001</td>
<td>Slave</td>
<td>159.138.51.216</td>
<td>CentOS 8.2 64bit</td>
</tr>
<tr>
<td>centos-istio-0002</td>
<td>Slave</td>
<td>159.138.57.247</td>
<td>CentOS 8.2 64bit</td>
</tr>
<tr>
<td>centos-istio-0003</td>
<td>Master</td>
<td>182.160.9.140</td>
<td>CentOS 8.2 64bit</td>
</tr>
</tbody></table>
<p>注⚠️：三台机器均已安装Docker。</p>
<h2 id="允许-iptables-检查桥接流量"><a href="#允许-iptables-检查桥接流量" class="headerlink" title="允许 iptables 检查桥接流量"></a>允许 iptables 检查桥接流量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>


<h2 id="安装-kubeadm、kubelet-和-kubectl"><a href="#安装-kubeadm、kubelet-和-kubectl" class="headerlink" title="安装 kubeadm、kubelet 和 kubectl"></a>安装 kubeadm、kubelet 和 kubectl</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">repo_gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">exclude=kubelet kubeadm kubectl</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> --now kubelet</span><br></pre></td></tr></table></figure>
<p>查看kubelet、kubeadm和kubectl是否安装成功</p>
<p><img src="/images/kube/kube-1.png"></p>
<h2 id="使用kubeadm安装master集群"><a href="#使用kubeadm安装master集群" class="headerlink" title="使用kubeadm安装master集群"></a>使用kubeadm安装master集群</h2><p><img src="/images/kube/kube-2.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address=192.168.0.96 --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/kube-3.png"></p>
<p>要使非 root 用户可以运行 kubectl，请运行以下命令， 它们也是 <code>kubeadm init</code> 输出的一部分：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>
<p>或者，如果你是 <code>root</code> 用户，则可以运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>


<h2 id="安装flannel网络"><a href="#安装flannel网络" class="headerlink" title="安装flannel网络"></a>安装flannel网络</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/kube-4.png"></p>
<h2 id="将Slave节点加入集群"><a href="#将Slave节点加入集群" class="headerlink" title="将Slave节点加入集群"></a>将Slave节点加入集群</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.0.96:6443 --token 8axber.2vzp1am4kcr7qpxd \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:10e0a25cc62687435f0211feeea1896d1ea512f3233a258ab0ef56a921224436</span><br></pre></td></tr></table></figure>
<p><img src="/images/kube/kube-5.png"></p>
<h2 id="查看集群节点状态"><a href="#查看集群节点状态" class="headerlink" title="查看集群节点状态"></a>查看集群节点状态</h2><p><img src="/images/kube/kube-6.png"></p>
]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Containerization</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux GoLang</title>
    <url>/2021/Linux-GoLang/</url>
    <content><![CDATA[<h3 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1. 下载安装包"></a>1. 下载安装包</h3><p>在Go语言下载官网 <a href="https://golang.org/dl/">https://golang.org/dl/</a> ，下载所需的Linux安装包</p>
<p><img src="/images/go/go-5.png"></p>
<h3 id="2-上传并解压"><a href="#2-上传并解压" class="headerlink" title="2. 上传并解压"></a>2. 上传并解压</h3><p>将下载的tar.gz包上传到Linux机器上，并使用<strong>tar -zxvf go1.16.2.linux-amd64.tar.gz</strong>解压</p>
<p><img src="/images/go/go-6.png"></p>
<h3 id="3-拷贝到-usr-local下"><a href="#3-拷贝到-usr-local下" class="headerlink" title="3. 拷贝到/usr/local下"></a>3. 拷贝到/usr/local下</h3><p>通过<strong>mv go /usr/local/go</strong>，将解压后的文件夹拷贝到/user/local下</p>
<p><img src="/images/go/go-7.png"></p>
<h3 id="4-查看go的版本号"><a href="#4-查看go的版本号" class="headerlink" title="4. 查看go的版本号"></a>4. 查看go的版本号</h3><p><img src="/images/go/go-8.png"></p>
<h3 id="5-设置环境变量"><a href="#5-设置环境变量" class="headerlink" title="5. 设置环境变量"></a>5. 设置环境变量</h3><p>编辑/etc/profile文件，并加入如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> GOPATH=~/golib:~/goproject</span><br><span class="line"><span class="built_in">export</span> GBIN=~/gobin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin/:<span class="variable">$GOBIN</span></span><br></pre></td></tr></table></figure>
<p>执行source /etc/profile命令使得环境变量生效</p>
<p><img src="/images/go/go-9.png"></p>
]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>KubeEdge Beehive</title>
    <url>/2021/KubeEdge-Beehive/</url>
    <content><![CDATA[<p>下载地址：<a href="https://github.com/kubeedge/kubeedge">https://github.com/kubeedge/kubeedge</a></p>
<p>版本：<a href="https://github.com/kubeedge/kubeedge/releases/tag/v1.5.0">KubeEdge v1.5.0 release</a></p>
]]></content>
      <categories>
        <category>Edge Computing</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Containerization</tag>
        <tag>KubeEdge</tag>
      </tags>
  </entry>
  <entry>
    <title>The Introduction to Kube-proxy</title>
    <url>/2021/The-Introduction-to-Kube-proxy/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Kube-proxy是Kubernetes的核心组件，部署在每个节点上。作为服务的透明代理兼负载均衡器（在K8s中，可以将提供相同服务的一组Pod可以抽象成一个服务，通过服务提供的统一入口对外提供服务，每个服务都有一个虚拟IP地址和端口号供客户端访问），其核心功能是将到某个服务的访问请求转发到后端的多个Pod实例上。Kube-proxy可以执行简单的 TCP、UDP 和 SCTP 流转发，或者在一组后端进行循环 TCP、UDP 和 SCTP 转发。</p>
<p>此外，服务的Cluster IP与NodePort等概念是kube-proxy服务通过iptables的NAT转换实现的，kube-proxy在运行过程中动态创建与服务相关的iptables规则，这些规则实现了将访问服务（Cluster IP或NodePort）的请求负载分发到后端Pod的功能。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Kube-proxy负责为Service提供集群内部的服务发现和负载均衡，在K8s的每个节点上都有一个Kube-proxy。因此，当需求访问服务的node越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也会随之增多。</p>
<p>如图所示，Kube-proxy从API Server获取所有的Server信息，并根据Server信息创建代理服务，实现从Server到Pod的请求路由和转发，从而实现K8s层级的虚拟转发网络。</p>
<img src="/images/kube/kube-7.png" alt="img" style="zoom:80%;" />

<p>Kube-proxy使用DaemonSet进行部署：DaemonSet管理K8s集群中每个node上仅运行一份Pod的副本实例。当node加入集群时创建Pod，当node离开集群时回收Pod。如果删除DaemonSet，其创建的所有Pod也被删除，DaemonSet中的Pod将覆盖整个集群。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><h3 id="Userspace模式"><a href="#Userspace模式" class="headerlink" title="Userspace模式"></a>Userspace模式</h3><p>在用户空间模式下，kube-proxy进程是一个TCP/UDP代理，负责从Service到Pod的访问流量的转发。当某个Pod以Cluster IP方式访问某个Service的时候，这个流量会被Pod所在本机的iptables转发到本机的kube-proxy进程，然后由kube-proxy建立起到后端Pod的TCP/UDP链接，随后将请求转发到某个后端的Pod上，并在这个过程中实现负载均衡功能。</p>
<img src="/images/kube/kube-8.png" alt="img" style="zoom:50%;" />

<p>kube-proxy 会为每个 Service 随机监听一个端口，并增加一条 IPtables 规则。从客户端到 ClusterIP:Port 的报文都会被重定向到该端口，而端口收到报文后，通过负载均衡策略分发给对应的 Pod。</p>
<p>用户空间模式的问题在于，Service的请求会先从用户空间进入内核iptables，然后再回到用户空间，由kube-proxy完成后端Endpoints的选择和代理工作，这样流量从用户空间进出内核带来的性能损耗是不可接受的。</p>
<h3 id="Iptables模式"><a href="#Iptables模式" class="headerlink" title="Iptables模式"></a>Iptables模式</h3><p>Iptable模式下的kube-proxy不再起到Proxy的作用，其核心功能：通过API Server的Watch接口实时追踪跟踪Service与Endpoint的变更信息，并更新对应的iptables规则，Client的请求流量则通过iptables的NAT机制“直接路由”到目标Pod。</p>
<img src="/images/kube/kube-9.png" alt="img" style="zoom:50%;" />

<p>Iptable模式是全自动模式：根据Kubernetes的网络模型，一个Node上的Pod与其他Node上的Pod应该能够直接建立双向的TCP/IP通信通道，所以如果直接修改iptables规则，则也可以实现kube-proxy的功能。并且，iptables模式完全工作在内核态，不再经过用户态的kube-proxy中转，因此性能更强。</p>
<p>Iptable模式的缺陷在于：在集群中的Service和Pod大量增加以后，iptables中的规则会急速膨胀，导致性能显著下降，在某些极端情况下甚至会出现规则丢失的情况，并且这种故障难以重现与排查。</p>
<h3 id="IPVS模式"><a href="#IPVS模式" class="headerlink" title="IPVS模式"></a>IPVS模式</h3><p>Iptables是为防火墙而设计的；IPVS（IP Virtual Server）则专门用于高性能负载均衡，并使用更高效的数据结构（Hash表），允许几乎无限的规模扩张。相比iptables，IPVS拥有一下明显优势：</p>
<p>· 为大型集群提供了更好的可扩展性和性能</p>
<p>· 支持比iptables更复杂的负载均衡算法（最小负载、最少连接、加权等）</p>
<p>· 支持服务器健康检查和连接重试等功能</p>
<p>· 可动态修改ipset的集合</p>
<img src="/images/kube/kube-10.png" alt="img" style="zoom:50%;" />

<p>Ipset是iptables的一种扩展，引入了带索引的数据结构。因此，当规则很多时，ipset可提供高效地查找和匹配。</p>
]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>ServiceMesh</tag>
      </tags>
  </entry>
  <entry>
    <title>EdgeMesh概述</title>
    <url>/2021/EdgeMesh%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>EdgeMesh是一种服务网格，它与KubeEdge紧密结合，并适用于边缘场景。</p>
<p>近年来，随着云原生和微服务架构的越来越流行，边缘节点的功能也越来越完善。在这个场景下，用户能够在边缘节点上部署自己的应用，而这些边缘节点必须通过服务被外部用户所访问。出于这个目的，EdgeMesh向用户（在KubeEdge内运行应用的用户）提供运行在不同节点上的外部访问服务，从而使他们访问其它边缘节点。此外，EdgeMesh还向用户供负载均衡和流量治理的能力。</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>EdgeMesh满足边缘场景下的新需求（如边缘资源有限，边云网络不稳定等），即实现了高可用性，高可靠性，和极致轻量化：</p>
<ul>
<li>高可用性<ul>
<li>利用KubeEdge中的边云通道，来打通边缘节点间的网络</li>
<li>将边缘节点间的通信分为局域网内和跨局域网<ul>
<li>局域网内的通信：直接访问</li>
<li>跨局域网的通信：通过云端转发</li>
</ul>
</li>
</ul>
</li>
<li>高可靠性 （离线场景）<ul>
<li>控制面和数据面流量都通过边云通道下发</li>
<li>EdgeMesh内部实现轻量级的DNS服务器，不再访问云端DNS</li>
</ul>
</li>
<li>极致轻量化<ul>
<li>每个节点有且仅有一个EdgeMesh，节省边缘资源</li>
</ul>
</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/images/kube/em-arch.jpg"></p>
<p>如图所示，Edgemesh的工作流如下：</p>
<ul>
<li>通过服务器域名，客户端向服务器发起请求</li>
<li>根据iptables规则，DNS被劫持到EdgeMesh，并返回一个虚假IP</li>
<li>根据iptables规则，请求也被劫持到EdgeMesh</li>
<li>EdgeMesh解析请求，获得域名，协议和请求等信息，</li>
<li>EdgeMesh的负载均衡：<ul>
<li>从域名中获得服务名和命名空间</li>
<li>在MetaManager中，查询该服务的后端Pods</li>
<li>基于负载均衡策略，选择一个后端Pod</li>
</ul>
</li>
<li>EdgeMesh向服务器传输请求，等待服务器的响应，并将响应返回给客户端</li>
</ul>
<h2 id="功能性"><a href="#功能性" class="headerlink" title="功能性"></a>功能性</h2><table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">子功能</th>
<th align="center">Edgemesh 0.1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">服务发现</td>
<td align="center"></td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center">流量治理</td>
<td align="center">HTTP</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">TCP</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">UDP</td>
<td align="center"><code>+</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">HTTPS</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Websocket</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">gRPC</td>
<td align="center"><code>+</code></td>
</tr>
<tr>
<td align="center">负载均衡</td>
<td align="center">随机</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">轮询</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">会话保持</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center">外部访问</td>
<td align="center"></td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center">多网卡监听</td>
<td align="center"></td>
<td align="center"><code>✓</code></td>
</tr>
</tbody></table>
<p>注：</p>
<ul>
<li><code>✓</code> EdgeMesh版本所支持的功能</li>
<li><code>+</code> EdgeMesh版本不具备的功能，但在后续版本中会支持</li>
<li><code>-</code> EdgeMesh版本不具备的功能，或已弃用的功能</li>
</ul>
<h2 id="操作指导"><a href="#操作指导" class="headerlink" title="操作指导"></a>操作指导</h2><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>在边缘节点，关闭edgemesh，打开metaserver，并重启edgecore</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/kubeedge/config/edgecore.yaml</span></span><br><span class="line">modules:</span><br><span class="line">  ..</span><br><span class="line">  edgeMesh:</span><br><span class="line">    enable: false</span><br><span class="line">  metaManager:</span><br><span class="line">    metaServer:</span><br><span class="line">      enable: true</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl restart edgecore</span></span><br></pre></td></tr></table></figure>
<p>在云端，开启dynamic controller模块，并重启cloudcore</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/kubeedge/config/cloudcore.yaml</span></span><br><span class="line">modules:</span><br><span class="line">  ..</span><br><span class="line">  dynamicController:</span><br><span class="line">    enable: true</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<p>在边缘节点，查看listwatch是否开启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl 127.0.0.1:10550/api/v1/services</span></span><br><span class="line">&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;items&quot;:[&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:&#123;&quot;creationTimestamp&quot;:&quot;2021-04-14T06:30:05Z&quot;,&quot;labels&quot;:&#123;&quot;component&quot;:&quot;apiserver&quot;,&quot;provider&quot;:&quot;kubernetes&quot;&#125;,&quot;name&quot;:&quot;kubernetes&quot;,&quot;namespace&quot;:&quot;default&quot;,&quot;resourceVersion&quot;:&quot;147&quot;,&quot;selfLink&quot;:&quot;default/services/kubernetes&quot;,&quot;uid&quot;:&quot;55eeebea-08cf-4d1a-8b04-e85f8ae112a9&quot;&#125;,&quot;spec&quot;:&#123;&quot;clusterIP&quot;:&quot;10.96.0.1&quot;,&quot;ports&quot;:[&#123;&quot;name&quot;:&quot;https&quot;,&quot;port&quot;:443,&quot;protocol&quot;:&quot;TCP&quot;,&quot;targetPort&quot;:6443&#125;],&quot;sessionAffinity&quot;:&quot;None&quot;,&quot;type&quot;:&quot;ClusterIP&quot;&#125;,&quot;status&quot;:&#123;&quot;loadBalancer&quot;:&#123;&#125;&#125;&#125;,&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&quot;prometheus.io/port&quot;:&quot;9153&quot;,&quot;prometheus.io/scrape&quot;:&quot;true&quot;&#125;,&quot;creationTimestamp&quot;:&quot;2021-04-14T06:30:07Z&quot;,&quot;labels&quot;:&#123;&quot;k8s-app&quot;:&quot;kube-dns&quot;,&quot;kubernetes.io/cluster-service&quot;:&quot;true&quot;,&quot;kubernetes.io/name&quot;:&quot;KubeDNS&quot;&#125;,&quot;name&quot;:&quot;kube-dns&quot;,&quot;namespace&quot;:&quot;kube-system&quot;,&quot;resourceVersion&quot;:&quot;203&quot;,&quot;selfLink&quot;:&quot;kube-system/services/kube-dns&quot;,&quot;uid&quot;:&quot;c221ac20-cbfa-406b-812a-c44b9d82d6dc&quot;&#125;,&quot;spec&quot;:&#123;&quot;clusterIP&quot;:&quot;10.96.0.10&quot;,&quot;ports&quot;:[&#123;&quot;name&quot;:&quot;dns&quot;,&quot;port&quot;:53,&quot;protocol&quot;:&quot;UDP&quot;,&quot;targetPort&quot;:53&#125;,&#123;&quot;name&quot;:&quot;dns-tcp&quot;,&quot;port&quot;:53,&quot;protocol&quot;:&quot;TCP&quot;,&quot;targetPort&quot;:53&#125;,&#123;&quot;name&quot;:&quot;metrics&quot;,&quot;port&quot;:9153,&quot;protocol&quot;:&quot;TCP&quot;,&quot;targetPort&quot;:9153&#125;],&quot;selector&quot;:&#123;&quot;k8s-app&quot;:&quot;kube-dns&quot;&#125;,&quot;sessionAffinity&quot;:&quot;None&quot;,&quot;type&quot;:&quot;ClusterIP&quot;&#125;,&quot;status&quot;:&#123;&quot;loadBalancer&quot;:&#123;&#125;&#125;&#125;],&quot;kind&quot;:&quot;ServiceList&quot;,&quot;metadata&quot;:&#123;&quot;resourceVersion&quot;:&quot;377360&quot;,&quot;selfLink&quot;:&quot;/api/v1/services&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>部署configmap，并创建Istio的用户自定义资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f 03-configmap.yaml</span></span><br><span class="line">configmap/edgemesh-cfg created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f istio-crds-simple.yaml</span></span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/virtualservices.networking.istio.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/destinationrules.networking.istio.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/serviceentries.networking.istio.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/gateways.networking.istio.io created</span><br></pre></td></tr></table></figure>
<p>使用daemonset的方式来部署edgemesh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f 05-daemonset.yaml</span></span><br><span class="line">daemonset.apps/edgemesh created</span><br></pre></td></tr></table></figure>


<h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><pre><code>**HTTP协议**

在边缘节点上，部署支持http协议的容器应用和相关服务</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f hostname.yaml</span></span><br></pre></td></tr></table></figure>
<pre><code>到边缘节点上，使用curl去访问相关服务，打印出容器的hostname</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl hostname-lb-svc.edgemesh-test:12345</span></span><br></pre></td></tr></table></figure>


<pre><code>**TCP协议**

在边缘节点1，部署支持tcp协议的容器应用和相关服务</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f tcp-echo-service.yaml</span></span><br></pre></td></tr></table></figure>
<pre><code>在边缘节点2，使用telnet去访问相关服务</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> telnet tcp-echo-service.edgemesh-test 2701</span></span><br></pre></td></tr></table></figure>


<pre><code>**Websocket协议**

在边缘节点1，部署支持websocket协议的容器应用和相关服务</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f websocket-pod-svc.yaml</span></span><br></pre></td></tr></table></figure>
<pre><code>进入websocket的容器环境，并使用client去访问相关服务</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it 2a6ae1a490ae bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./client --addr ws-svc.edgemesh-test:12348</span></span><br></pre></td></tr></table></figure>


<pre><code>**负载均衡**

使用DestinationRule中的loadBalancer属性来选择不同的负载均衡模式</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim edgemesh-gateway-dr.yaml</span></span><br><span class="line">spec</span><br><span class="line">..</span><br><span class="line">  trafficPolicy:</span><br><span class="line">    loadBalancer:</span><br><span class="line">      simple: RANDOM</span><br><span class="line">..    </span><br></pre></td></tr></table></figure>


<h2 id="Edgemesh-Ingress-Gateway"><a href="#Edgemesh-Ingress-Gateway" class="headerlink" title="Edgemesh Ingress Gateway"></a>Edgemesh Ingress Gateway</h2><p>Edgemesh ingress gateway 提供了外部访问集群里服务的能力。</p>
<p><img src="/images/kube/em-001.png"></p>
<h3 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h3><p>创建istio的用户自定义资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f istio-crds-simple.yaml</span></span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/virtualservices.networking.istio.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/destinationrules.networking.istio.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/serviceentries.networking.istio.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/gateways.networking.istio.io created</span><br></pre></td></tr></table></figure>
<p>配置configmap，并使用deployment来部署edgemesh-gateway</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f 03-configmap.yaml</span> </span><br><span class="line">configmap/edgemesh-gateway-cfg created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f 04-deployment.yaml</span> </span><br><span class="line">deployment.apps/edgemesh-gateway created</span><br></pre></td></tr></table></figure>
<p>创建gateway资源对象，和路由规则Virtual Service</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f edgemesh-gateway-gw-vsvc.yaml</span></span><br><span class="line">gateway.networking.istio.io/edgemesh-gateway created</span><br><span class="line">virtualservice.networking.istio.io/edgemesh-gateway-vsvc created</span><br></pre></td></tr></table></figure>
<p>查看edgemesh-gateway是否部署成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get gw -n edgemesh-test</span></span><br><span class="line">NAME               AGE</span><br><span class="line">edgemesh-gateway   3m30s</span><br></pre></td></tr></table></figure>
<p>最后，使用IP和Virtual Service暴露的端口来进行访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl 192.168.0.211:23333</span></span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/xiaoli777/edgemesh">https://github.com/xiaoli777/edgemesh</a></p>
<p><a href="https://docs.kubeedge.io/en/docs/advanced/edgemesh/">https://docs.kubeedge.io/en/docs/advanced/edgemesh/</a></p>
]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>KubeEdge</tag>
        <tag>ServiceMesh</tag>
      </tags>
  </entry>
  <entry>
    <title>Sorting Algorithms</title>
    <url>/2021/Sorting-Algorithms/</url>
    <content><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul>
<li>概念：从头到尾逐个处理数据，将当前数据和它前面的序列进行比较：若当前数据小于前一个数据，则交换位置；否则移动数组，处理下一个数据。</li>
<li>特征：稳定性</li>
<li>时间复杂度：O(n) / O(n^2) / O(n^2)</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>概念：从头到尾逐个处理数据，每次将当前数据和它后面的序列进行比较：若当前数据大于后一个数据，则交换位置，并后移下标；否则仅后移下标。</li>
<li>特征：稳定性</li>
<li>时间复杂度：O(n^2) / O(n^2) / O(n^2)</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul>
<li>概念：第i次选择数组中第i小的数值，插入到第i个位置。</li>
<li>特征：不稳定性</li>
<li>时间复杂度：O(n^2) / O(n^2) / O(n^2)</li>
</ul>
<h2 id="shell排序"><a href="#shell排序" class="headerlink" title="shell排序"></a>shell排序</h2><ul>
<li>概念：用INTERVAL将数组等分划分，对较小的划分数组进行插入排序，再将较小的划分数组合并为较大的数据，并进行插入排序，直到得到完整的有序数组。</li>
<li>特征：不稳定性</li>
<li>时间复杂度(INTERVAL=3)：O(n) / O(n^2) / O(n^1.5)</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li>概念：选择数组中的一个数字作为轴值，将比轴值小的数放在轴值左边，比轴值大的数放在轴值右边，并通过递归依次处理轴值左边和右边的序列。</li>
<li>特征：不稳定性</li>
<li>时间复杂度：O(nlogn) / O(n^2) / O(nlogn)</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li>概念：每次通过递归将数组划分为长度相同的子序列，并用临时数组来进行排序；接着将子序列合并为一个更大的数组并排序。</li>
<li>特征：稳定性 / 使用等长度的临时数组(也可以通过reverse来实现)</li>
<li>时间复杂度：O(nlogn) / O(nlogn) / O(nlogn)</li>
</ul>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li>概念：构建最大堆，每次将堆顶元素弹出，并用剩余元素继续构建最大堆，直到空堆。</li>
<li>特征：不稳定性</li>
<li>时间复杂度：O(nlogn)</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>The Overview of EdgeMesh</title>
    <url>/2021/The-Overview-of-EdgeMesh/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>EdgeMesh is a type of service mesh, which is closely related to KubeEdge, and is applicable to the edge scenarios.</p>
<p>In recent years, as cloud native and microservice architectures have become more and more popular, the functions of edge nodes have become more and more complete. In this scenario, users can deploy their own applications on edge nodes, and these edge nodes must be accessed by external users through services. For this purpose, EdgeMesh provides users (users running applications in KubeEdge) with external access services running on different nodes, allowing them to access other edge nodes. In addition, EdgeMesh also provides capabilities of load balancing and traffic management for users.</p>
<h2 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h2><p>EdgeMesh satisfies the new requirements in edge scenarios (e.g., limited edge resources, unstable edge cloud network, etc.), that is, high availability, high reliability, and extreme lightweight:</p>
<ul>
<li>High availability<ul>
<li>Open up the network between edge nodes by using the edge cloud channel in KubeEdge</li>
<li>Divide the communication between edge nodes into intra-LAN and cross-LAN<ul>
<li>Intra-LAN communication: direct access</li>
<li>Cross-LAN communication: forwarding through the cloud</li>
</ul>
</li>
</ul>
</li>
<li>High reliability (offline scenario)<ul>
<li>Both control plane and data plane traffic are delivered through the edge cloud channel</li>
<li>EdgeMesh internally implements a lightweight DNS server, thus no longer accessing the cloud DNS</li>
</ul>
</li>
<li>Extreme lightweight<ul>
<li>Each node has one and only one EdgeMesh, which saves edge resources</li>
</ul>
</li>
</ul>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p><img src="/images/kube/em-arch.jpg"></p>
<p>As shwn in figure above, the workflow of EdgeMesh is as following:</p>
<ul>
<li>Client sends a request to server by server’s domain name</li>
<li>DNS is hijacked to EdgeMesh by iptables rules, then a fake IP returned</li>
<li>The request is also hijacked to EdgeMesh by iptables rules</li>
<li>EdgeMesh resolves the request, gets domain name, protocol, request and so on</li>
<li>The load balancing of EdgeMesh: <ul>
<li>Gets the service name and namespace from the domain name </li>
<li>Queries backend pods of the service from MetaManager </li>
<li>Chooses a backend based on the LB strategy </li>
</ul>
</li>
<li>EdgeMesh transports the request to server, waits for a response from server, and then sends the response back to the client</li>
</ul>
<h2 id="Functionality"><a href="#Functionality" class="headerlink" title="Functionality"></a>Functionality</h2><table>
<thead>
<tr>
<th align="center">Feature</th>
<th align="center">Sub-Feature</th>
<th align="center">Edgemesh 0.1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Service Discovery</td>
<td align="center"></td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center">Traffic Governance</td>
<td align="center">HTTP</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">TCP</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">UDP</td>
<td align="center"><code>+</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">HTTPS</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Websocket</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">gRPC</td>
<td align="center"><code>+</code></td>
</tr>
<tr>
<td align="center">Load Balance</td>
<td align="center">Random</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Round Robin</td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Session Persistence</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">External Access</td>
<td align="center"></td>
<td align="center"><code>✓</code></td>
</tr>
<tr>
<td align="center">Multi-NIC Monitoring</td>
<td align="center"></td>
<td align="center"><code>✓</code></td>
</tr>
</tbody></table>
<p>Noting：</p>
<ul>
<li><code>✓</code> Features supported by the EdgeMesh version </li>
<li><code>+</code> Features not available in the EdgeMesh version, but will be supported in subsequent versions</li>
<li><code>-</code> Features not available in the EdgeMesh version, or deprecated features</li>
</ul>
<h2 id="Operation-Guidance"><a href="#Operation-Guidance" class="headerlink" title="Operation Guidance"></a>Operation Guidance</h2><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><pre><code>At the edge node, close EdgeMesh, open metaserver, and restart edgecore</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/kubeedge/config/edgecore.yaml</span></span><br><span class="line">modules:</span><br><span class="line">  ..</span><br><span class="line">  edgeMesh:</span><br><span class="line">    enable: false</span><br><span class="line">  metaManager:</span><br><span class="line">    metaServer:</span><br><span class="line">      enable: true</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl restart edgecore</span></span><br></pre></td></tr></table></figure>
<pre><code>On the cloud, open the dynamic controller module, and restart cloudcore</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/kubeedge/config/cloudcore.yaml</span></span><br><span class="line">modules:</span><br><span class="line">  ..</span><br><span class="line">  dynamicController:</span><br><span class="line">    enable: true</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<pre><code>At the edge node, check if listwatch works</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl 127.0.0.1:10550/api/v1/services</span></span><br><span class="line">&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;items&quot;:[&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:&#123;&quot;creationTimestamp&quot;:&quot;2021-04-14T06:30:05Z&quot;,&quot;labels&quot;:&#123;&quot;component&quot;:&quot;apiserver&quot;,&quot;provider&quot;:&quot;kubernetes&quot;&#125;,&quot;name&quot;:&quot;kubernetes&quot;,&quot;namespace&quot;:&quot;default&quot;,&quot;resourceVersion&quot;:&quot;147&quot;,&quot;selfLink&quot;:&quot;default/services/kubernetes&quot;,&quot;uid&quot;:&quot;55eeebea-08cf-4d1a-8b04-e85f8ae112a9&quot;&#125;,&quot;spec&quot;:&#123;&quot;clusterIP&quot;:&quot;10.96.0.1&quot;,&quot;ports&quot;:[&#123;&quot;name&quot;:&quot;https&quot;,&quot;port&quot;:443,&quot;protocol&quot;:&quot;TCP&quot;,&quot;targetPort&quot;:6443&#125;],&quot;sessionAffinity&quot;:&quot;None&quot;,&quot;type&quot;:&quot;ClusterIP&quot;&#125;,&quot;status&quot;:&#123;&quot;loadBalancer&quot;:&#123;&#125;&#125;&#125;,&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&quot;prometheus.io/port&quot;:&quot;9153&quot;,&quot;prometheus.io/scrape&quot;:&quot;true&quot;&#125;,&quot;creationTimestamp&quot;:&quot;2021-04-14T06:30:07Z&quot;,&quot;labels&quot;:&#123;&quot;k8s-app&quot;:&quot;kube-dns&quot;,&quot;kubernetes.io/cluster-service&quot;:&quot;true&quot;,&quot;kubernetes.io/name&quot;:&quot;KubeDNS&quot;&#125;,&quot;name&quot;:&quot;kube-dns&quot;,&quot;namespace&quot;:&quot;kube-system&quot;,&quot;resourceVersion&quot;:&quot;203&quot;,&quot;selfLink&quot;:&quot;kube-system/services/kube-dns&quot;,&quot;uid&quot;:&quot;c221ac20-cbfa-406b-812a-c44b9d82d6dc&quot;&#125;,&quot;spec&quot;:&#123;&quot;clusterIP&quot;:&quot;10.96.0.10&quot;,&quot;ports&quot;:[&#123;&quot;name&quot;:&quot;dns&quot;,&quot;port&quot;:53,&quot;protocol&quot;:&quot;UDP&quot;,&quot;targetPort&quot;:53&#125;,&#123;&quot;name&quot;:&quot;dns-tcp&quot;,&quot;port&quot;:53,&quot;protocol&quot;:&quot;TCP&quot;,&quot;targetPort&quot;:53&#125;,&#123;&quot;name&quot;:&quot;metrics&quot;,&quot;port&quot;:9153,&quot;protocol&quot;:&quot;TCP&quot;,&quot;targetPort&quot;:9153&#125;],&quot;selector&quot;:&#123;&quot;k8s-app&quot;:&quot;kube-dns&quot;&#125;,&quot;sessionAffinity&quot;:&quot;None&quot;,&quot;type&quot;:&quot;ClusterIP&quot;&#125;,&quot;status&quot;:&#123;&quot;loadBalancer&quot;:&#123;&#125;&#125;&#125;],&quot;kind&quot;:&quot;ServiceList&quot;,&quot;metadata&quot;:&#123;&quot;resourceVersion&quot;:&quot;377360&quot;,&quot;selfLink&quot;:&quot;/api/v1/services&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<pre><code>Deploy configmap, and create Istio&#39;s crds</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f 03-configmap.yaml</span></span><br><span class="line">configmap/edgemesh-cfg created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f istio-crds-simple.yaml</span></span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/virtualservices.networking.istio.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/destinationrules.networking.istio.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/serviceentries.networking.istio.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/gateways.networking.istio.io created</span><br></pre></td></tr></table></figure>
<pre><code>Use daemonset to deploy EdgeMesh</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f 05-daemonset.yaml</span></span><br><span class="line">daemonset.apps/edgemesh created</span><br></pre></td></tr></table></figure>


<h4 id="Test-Case"><a href="#Test-Case" class="headerlink" title="Test Case"></a>Test Case</h4><pre><code>**HTTP**

At the edge node, deploy a HTTP container application, and relevant service</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f hostname.yaml</span></span><br></pre></td></tr></table></figure>
<pre><code>Go to that edge node, use ‘curl’ to access the service, and print out the hostname of the container</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl hostname-lb-svc.edgemesh-test:12345</span></span><br></pre></td></tr></table></figure>


<pre><code>**TCP**

At the edge node 1, deploy a TCP container application, and relevant service    </code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f tcp-echo-service.yaml</span></span><br></pre></td></tr></table></figure>
<pre><code>At the edge node 1, use ‘telnet’ to access the service        </code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> telnet tcp-echo-service.edgemesh-test 2701</span></span><br></pre></td></tr></table></figure>


<pre><code>**Websocket**

At the edge node, deploy a websocket container application, and relevant service    </code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f websocket-pod-svc.yaml</span></span><br></pre></td></tr></table></figure>
<pre><code>Enter the container, and use ./client to access the service</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it 2a6ae1a490ae bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./client --addr ws-svc.edgemesh-test:12348</span></span><br></pre></td></tr></table></figure>


<pre><code>**Load Balance**

Use the &#39;loadBalancer&#39; in &#39;DestinationRule&#39; to select LB modes    </code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim edgemesh-gateway-dr.yaml</span></span><br><span class="line">spec</span><br><span class="line">..</span><br><span class="line">  trafficPolicy:</span><br><span class="line">    loadBalancer:</span><br><span class="line">      simple: RANDOM</span><br><span class="line">..    </span><br></pre></td></tr></table></figure>


<h2 id="Edgemesh-Ingress-Gateway"><a href="#Edgemesh-Ingress-Gateway" class="headerlink" title="Edgemesh Ingress Gateway"></a>Edgemesh Ingress Gateway</h2><p>Edgemesh Ingress Gateway provides a ability to access services in external edge nodes.</p>
<p><img src="/images/kube/em-001.png"></p>
<h4 id="Deployment-1"><a href="#Deployment-1" class="headerlink" title="Deployment"></a>Deployment</h4><p>Create Istio’s crds</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f istio-crds-simple.yaml</span></span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/virtualservices.networking.istio.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/destinationrules.networking.istio.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/serviceentries.networking.istio.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/gateways.networking.istio.io created</span><br></pre></td></tr></table></figure>
<p>Configure configmap, and deploy edgemesh-gateway</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f 03-configmap.yaml</span> </span><br><span class="line">configmap/edgemesh-gateway-cfg created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f 04-deployment.yaml</span> </span><br><span class="line">deployment.apps/edgemesh-gateway created</span><br></pre></td></tr></table></figure>
<p>Create ‘gateway’ and ‘Virtual Service’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f edgemesh-gateway-gw-vsvc.yaml</span></span><br><span class="line">gateway.networking.istio.io/edgemesh-gateway created</span><br><span class="line">virtualservice.networking.istio.io/edgemesh-gateway-vsvc created</span><br></pre></td></tr></table></figure>
<p>Check if the edgemesh-gateway is successfully deployed</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get gw -n edgemesh-test</span></span><br><span class="line">NAME               AGE</span><br><span class="line">edgemesh-gateway   3m30s</span><br></pre></td></tr></table></figure>
<p>Finally, use the IP and the port exposed by the Virtual Service to access</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl 192.168.0.211:23333</span></span><br></pre></td></tr></table></figure>


<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/xiaoli777/edgemesh">https://github.com/xiaoli777/edgemesh</a></p>
<p><a href="https://docs.kubeedge.io/en/docs/advanced/edgemesh/">https://docs.kubeedge.io/en/docs/advanced/edgemesh/</a></p>
]]></content>
      <categories>
        <category>Cloud Computing</category>
      </categories>
      <tags>
        <tag>KubeEdge</tag>
        <tag>ServiceMesh</tag>
      </tags>
  </entry>
</search>
